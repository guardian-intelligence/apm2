ticket_meta:
  schema_version: '2026-01-27'
  template_version: '2026-01-27'
  ticket:
    id: TCK-00161
    title: Implement PTY spawning and output capture
    status: "CLOSED"
  binds:
    rfc_id: RFC-0013
    requirements:
    - requirement_id: REQ-ADAPTER-001
dependencies:
  tickets:
  - ticket_id: TCK-00160
acceptance_criteria:
- criterion: PTY allocation and child process spawning via nix
  verification: Unit test spawns process with PTY
- criterion: Output capture with sequence numbers and timestamps
  verification: Output stream includes seq/ts metadata
- criterion: Ring buffer for flight recorder
  verification: Buffer overflow triggers oldest eviction
implementation:
  code_examples:
  - description: PTY output structure
    code: "pub struct PtyOutput {\n    pub chunk: Bytes,\n    pub seq: u64,\n    pub\
      \ ts_mono: u64,\n    pub kind: StreamKind,\n}\n\npub struct PtyRunner {\n  \
      \  master_fd: OwnedFd,\n    child_pid: Pid,\n    output_rx: mpsc::Receiver<PtyOutput>,\n\
      \    ring_buffer: RingBuffer<PtyOutput>,\n}\n"
  files_to_create:
  - path: crates/apm2-daemon/src/episode/pty.rs
    purpose: PTY spawning and management
  - path: crates/apm2-daemon/src/episode/ring_buffer.rs
    purpose: Fixed-size ring buffer for flight recorder
  - path: crates/apm2-daemon/src/episode/output.rs
    purpose: Output capture with metadata
  files_to_modify:
  - changes: Export pty, ring_buffer, output modules
    path: crates/apm2-daemon/src/episode/mod.rs
  implementation_steps:
  - step: 1
    action: Implement PTY spawning
    details: 'Use nix::pty::openpty() to create PTY pair.

      Fork child process with:

      - setsid() for new session

      - dup2() to connect slave to stdin/stdout/stderr

      - execvp() for harness command

      '
  - step: 2
    action: Implement output capture
    details: 'Spawn async task reading from master fd:

      - Add sequence number (monotonic u64)

      - Add timestamp (monotonic clock)

      - Classify as STDOUT or STDERR

      - Send to mpsc channel

      '
  - step: 3
    action: Implement ring buffer
    details: 'Create generic RingBuffer<T>:

      - Fixed capacity configured per risk tier

      - push() evicts oldest on overflow

      - drain() returns all items

      - capacity() and len() methods

      '
  - step: 4
    action: Integrate with flight recorder
    details: 'PtyRunner maintains ring buffer of recent output:

      - Default: 1MB for tier 1, 4MB for tier 2, 16MB for tier 3+

      - persist() method flushes to CAS on trigger

      - clear() method empties buffer

      '
  - step: 5
    action: Handle process lifecycle
    details: 'PtyRunner methods:

      - send_input(data: &[u8]) writes to master

      - signal(sig: Signal) sends to child

      - wait() returns ExitStatus

      - resize(cols, rows) updates PTY dimensions

      '
  summary: 'Implement PTY spawning and output capture with ring buffer for flight
    recorder.

    Uses nix crate for PTY allocation and process management. Output includes

    sequence numbers and timestamps for evidence ordering.

    '
notes: 'Phase: PHASE-1C (PTY Runner and Basic Adapter)

  Generated from RFC RFC-0013 DECOMPOSE session on 2026-01-27.

  Maps to TCK-PEND-005.

  '
test_requirements:
- description: PTY spawn and output
  test_id: UT-00161-01
  verification_command: cargo test -p apm2-daemon pty_spawn
- description: Ring buffer overflow
  test_id: UT-00161-02
  verification_command: cargo test -p apm2-daemon ring_buffer
- description: Output sequencing
  test_id: UT-00161-03
  verification_command: cargo test -p apm2-daemon output_sequence
