schema_version: "2026-01-26"
template_version: "2026-01-26"

ticket:
  id: TCK-00112
  title: "Implement CCP crate graph generation"
  status: READY
  rfc_id: RFC-0010
  requirement_ids:
    - REQ-0002
  depends_on:
    - TCK-00110

implementation:
  summary: |
    Create the CCP crate graph generator that invokes cargo metadata to build
    a deterministic dependency graph of all workspace crates. The graph captures
    inter-crate dependencies with version constraints, enabling impact analysis
    when changes propagate through the dependency tree.

  files_to_modify: []

  files_to_create:
    - path: "crates/apm2-core/src/ccp/crate_graph.rs"
      purpose: "Crate graph generation: invoke cargo metadata, parse output, produce deterministic graph structure"

  implementation_steps:
    - step: 1
      action: "Define crate graph data structures"
      details: |
        In crate_graph.rs, define:

        pub struct CrateGraph {
            pub schema_version: String,
            pub generated_at: DateTime<Utc>,
            pub workspace_root: PathBuf,
            pub crates: Vec<CrateNode>,
            pub edges: Vec<DependencyEdge>,
        }

        pub struct CrateNode {
            pub id: String,           // Matches component ID from atlas
            pub name: String,         // Crate name from Cargo.toml
            pub version: String,      // Version from Cargo.toml
            pub path: PathBuf,        // Crate root path
            pub crate_type: CrateType,
            pub features: Vec<String>,
        }

        pub enum CrateType { Lib, Bin, ProcMacro }

        pub struct DependencyEdge {
            pub from: String,         // Source crate ID
            pub to: String,           // Target crate ID
            pub dep_type: DependencyType,
            pub version_req: String,  // Version requirement (e.g., "0.1", "^1.0")
            pub features: Vec<String>,
            pub optional: bool,
        }

        pub enum DependencyType { Normal, Dev, Build }

    - step: 2
      action: "Implement cargo metadata invocation"
      details: |
        fn invoke_cargo_metadata(repo_root: &Path) -> Result<serde_json::Value, CrateGraphError>
        - Run: cargo metadata --format-version 1 --manifest-path <repo_root>/Cargo.toml
        - Capture stdout as JSON
        - Handle errors: cargo not found, invalid manifest, etc.
        - Consider using cargo_metadata crate if available, or raw Command

    - step: 3
      action: "Implement metadata parsing"
      details: |
        fn parse_cargo_metadata(metadata: &serde_json::Value) -> Result<(Vec<CrateNode>, Vec<DependencyEdge>), CrateGraphError>
        - Extract workspace_root from metadata
        - Extract packages array, filter to workspace members only
        - For each package, create CrateNode with stable ID
        - Extract dependencies from resolve.nodes for edges
        - Handle optional dependencies and feature flags

    - step: 4
      action: "Implement deterministic sorting"
      details: |
        fn sort_graph(crates: &mut Vec<CrateNode>, edges: &mut Vec<DependencyEdge>)
        - Sort crates by ID (lexicographic)
        - Sort edges by (from, to, dep_type) tuple
        - This ensures cargo metadata output order variations don't affect output

    - step: 5
      action: "Implement build_crate_graph"
      details: |
        pub fn build_crate_graph(repo_root: &Path) -> Result<CrateGraph, CrateGraphError>
        1. Invoke cargo metadata
        2. Parse metadata into nodes and edges
        3. Sort deterministically
        4. Return CrateGraph with schema_version and generated_at

    - step: 6
      action: "Add to CCP module"
      details: |
        Update crates/apm2-core/src/ccp/mod.rs:
        pub mod crate_graph;
        pub use crate_graph::{CrateGraph, CrateNode, DependencyEdge, CrateGraphError};

  code_examples:
    - description: "Building a crate graph"
      code: |
        use apm2_core::ccp::build_crate_graph;
        use std::path::Path;

        let graph = build_crate_graph(Path::new("/repo/root"))?;
        println!("Workspace has {} crates", graph.crates.len());
        for edge in &graph.edges {
            println!("{} -> {} ({})", edge.from, edge.to, edge.version_req);
        }

    - description: "Finding dependents of a crate"
      code: |
        fn find_dependents(graph: &CrateGraph, crate_id: &str) -> Vec<&str> {
            graph.edges.iter()
                .filter(|e| e.to == crate_id)
                .map(|e| e.from.as_str())
                .collect()
        }

acceptance_criteria:
  - criterion: "Crate graph matches cargo metadata output structure"
    verification: "Integration test compares crate graph nodes/edges against direct cargo metadata parsing - all workspace crates and their dependencies present"
  - criterion: "Output is deterministic (stable key ordering)"
    verification: "Unit test runs build_crate_graph twice - serialized YAML output must be byte-identical"

test_requirements:
  - test_id: UT-112-01
    description: "Test cargo metadata invocation succeeds"
    verification_command: "cargo test -p apm2-core ccp::crate_graph::tests::test_cargo_metadata_invocation"
  - test_id: UT-112-02
    description: "Test metadata parsing extracts all workspace crates"
    verification_command: "cargo test -p apm2-core ccp::crate_graph::tests::test_parse_workspace_crates"
  - test_id: UT-112-03
    description: "Test dependency edges are correctly extracted"
    verification_command: "cargo test -p apm2-core ccp::crate_graph::tests::test_dependency_edges"
  - test_id: UT-112-04
    description: "Test output is deterministically sorted"
    verification_command: "cargo test -p apm2-core ccp::crate_graph::tests::test_deterministic_output"
  - test_id: UT-112-05
    description: "Test optional dependencies are marked correctly"
    verification_command: "cargo test -p apm2-core ccp::crate_graph::tests::test_optional_dependencies"
  - test_id: IT-112-01
    description: "Integration test: full crate graph build"
    verification_command: "cargo test -p apm2-core ccp::crate_graph"

notes: |
  The crate graph provides structural information about how crates depend on
  each other. Combined with the component atlas (which provides semantic
  information), this enables accurate impact analysis.

  The cargo_metadata crate (https://crates.io/crates/cargo_metadata) can be
  used instead of raw Command invocation if it's already a dependency or
  acceptable to add. It provides type-safe parsing of cargo metadata output.

  Blocked by TCK-00110 because crate graph output must use canonical YAML
  from the determinism module. This ticket can be implemented in parallel
  with TCK-00111 (component atlas) as they are independent.
