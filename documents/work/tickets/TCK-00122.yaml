schema_version: "2026-01-26"
template_version: "2026-01-26"

ticket:
  id: TCK-00122
  title: "Implement Refactor Radar stage"
  status: READY
  rfc_id: RFC-0010
  requirement_ids:
    - REQ-0011
  depends_on:
    - TCK-00120

implementation:
  summary: |
    Create the Refactor Radar module that aggregates CCP signals (hotspots,
    duplication heuristics, complexity metrics) into bounded, prioritized
    maintenance recommendations. Includes CLI command for on-demand analysis
    and circuit breaker to suspend output when maintenance backlog exceeds
    configurable threshold.

  files_to_create:
    - path: "crates/apm2-core/src/refactor_radar/mod.rs"
      purpose: "Module entry point exposing radar and signals submodules"

    - path: "crates/apm2-core/src/refactor_radar/radar.rs"
      purpose: "Core radar logic aggregating signals into recommendations"

    - path: "crates/apm2-core/src/refactor_radar/signals.rs"
      purpose: "Signal collectors for hotspots, duplication, complexity"

    - path: "crates/apm2-cli/src/commands/factory/refactor.rs"
      purpose: "CLI command for refactor radar invocation"

  files_to_modify:
    - path: "crates/apm2-core/src/lib.rs"
      changes: "Add pub mod refactor_radar declaration"

    - path: "crates/apm2-cli/src/main.rs"
      changes: "Register refactor subcommand under factory"

  implementation_steps:
    - step: 1
      action: "Define signal types"
      details: |
        In signals.rs:
        - HotspotSignal: files with high churn rate in time window
        - DuplicationSignal: heuristic matches for cousin abstractions
        - ComplexitySignal: files exceeding complexity thresholds
        - Each signal includes: source_path, severity, evidence, suggested_action

    - step: 2
      action: "Implement signal collectors"
      details: |
        In signals.rs:
        - HotspotCollector: analyze git log for file churn
        - DuplicationCollector: pattern match for similar structures
        - ComplexityCollector: analyze code metrics (cyclomatic, etc.)
        - Each collector returns Vec<Signal> for its category

        **HotspotCollector git command:**
        ```rust
        use std::process::Command;

        fn collect_hotspots(repo_root: &Path, window: Duration) -> Vec<HotspotSignal> {
            let since = format!("--since={} days ago", window.as_secs() / 86400);
            let output = Command::new("git")
                .args(["log", "--format=%H", "--name-only", &since])
                .current_dir(repo_root)
                .output()
                .expect("git command failed");

            let stdout = String::from_utf8_lossy(&output.stdout);
            let mut file_counts: HashMap<String, usize> = HashMap::new();

            // Parse git log output: commit hashes followed by file paths
            for line in stdout.lines() {
                let line = line.trim();
                if line.is_empty() || line.len() == 40 { // skip empty lines and commit hashes
                    continue;
                }
                *file_counts.entry(line.to_string()).or_insert(0) += 1;
            }

            // Convert to signals, sorted by count descending
            file_counts.into_iter()
                .map(|(path, count)| HotspotSignal {
                    source_path: PathBuf::from(path),
                    churn_count: count,
                    severity: if count > 20 { "high" } else if count > 10 { "medium" } else { "low" },
                })
                .collect()
        }
        ```

    - step: 3
      action: "Implement radar aggregation"
      details: |
        In radar.rs:
        - Radar struct aggregates signals from all collectors
        - Prioritization logic based on severity and recency
        - Bounded output: configurable max_recommendations (default: 10)
        - Recommendations include: priority rank, rationale, suggested ticket

    - step: 4
      action: "Implement circuit breaker"
      details: |
        In radar.rs:
        - CircuitBreaker checks existing maintenance ticket count
        - If backlog_count > backlog_threshold, suspend output
        - Return CircuitBreakerTripped status with current count
        - Configurable threshold (default: 20 open maintenance tickets)

    - step: 5
      action: "Implement CLI command"
      details: |
        In refactor.rs:
        - apm2 factory refactor radar --window <DURATION>
        - --window: time window for analysis (e.g., 7d, 30d)
        - --max-items: override max recommendations
        - --ignore-breaker: force output even if circuit breaker tripped
        - Output as YAML or JSON

    - step: 6
      action: "Wire up modules"
      details: |
        In mod.rs, lib.rs, main.rs:
        - Export public types
        - Add module declaration to crate root
        - Register CLI command

  code_examples:
    - description: "CLI usage"
      code: |
        # Analyze last 7 days of changes
        apm2 factory refactor radar --window 7d

        # Increase recommendation limit
        apm2 factory refactor radar --window 30d --max-items 20

        # Force output even if backlog is high
        apm2 factory refactor radar --window 7d --ignore-breaker

    - description: "Recommendation output structure"
      code: |
        recommendations:
          - priority: 1
            signal_type: hotspot
            source_path: "crates/apm2-core/src/legacy/parser.rs"
            rationale: "Modified 47 times in last 7 days, high churn indicates instability"
            suggested_action: "Consider refactoring into smaller modules"
            suggested_ticket:
              title: "Refactor parser.rs to reduce churn"
              type: maintenance

          - priority: 2
            signal_type: duplication
            source_path: "crates/apm2-cli/src/commands/build.rs"
            rationale: "85% structural similarity with deploy.rs"
            suggested_action: "Extract common logic to shared module"

        circuit_breaker:
          status: ok
          current_backlog: 8
          threshold: 20

acceptance_criteria:
  - criterion: "Radar output is bounded"
    verification: "Tests verify output never exceeds max_recommendations setting"

  - criterion: "Recommendations include prioritization"
    verification: "Each recommendation includes priority rank and rationale explaining ranking"

  - criterion: "Circuit breaker suspends output when backlog exceeds threshold"
    verification: "Tests verify no recommendations emitted when backlog > threshold (unless --ignore-breaker)"

test_requirements:
  - test_id: UT-122-01
    description: "Test hotspot signal collection from git history"
    verification_command: "cargo test -p apm2-core refactor_radar::signals::hotspot"

  - test_id: UT-122-02
    description: "Test duplication signal heuristic matching"
    verification_command: "cargo test -p apm2-core refactor_radar::signals::duplication"

  - test_id: UT-122-03
    description: "Test radar aggregation respects max_recommendations bound"
    verification_command: "cargo test -p apm2-core refactor_radar::radar::bounded"

  - test_id: UT-122-04
    description: "Test circuit breaker trips when backlog exceeds threshold"
    verification_command: "cargo test -p apm2-core refactor_radar::radar::circuit_breaker"

  - test_id: IT-122-05
    description: "Integration test for CLI command"
    verification_command: "cargo run --bin apm2 -- factory refactor radar --window 7d"

notes: |
  This ticket implements REQ-0011 (refactor radar) from RFC-0010.

  Key design decisions:
  - Bounded output prevents overwhelming developers with recommendations.
  - Prioritization uses weighted scoring: severity * recency * impact.
  - Circuit breaker prevents recommendation pile-up when maintenance backlog
    is already high, avoiding "recommendation fatigue".
  - Duplication detection uses structural heuristics, not exact matching,
    to catch "cousin abstractions" that share patterns but not code.

  CCP grounding: COMP-CORE module, operates on CCP signals.

  The Refactor Radar is designed as a sustainable maintenance tool that
  respects team capacity through bounded output and circuit breaker logic.
