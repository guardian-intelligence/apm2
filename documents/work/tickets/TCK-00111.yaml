schema_version: "2026-01-26"
template_version: "2026-01-26"

ticket:
  id: TCK-00111
  title: "Implement CCP component atlas generation"
  status: READY
  rfc_id: RFC-0010
  requirement_ids:
    - REQ-0002
  depends_on:
    - TCK-00110

implementation:
  summary: |
    Create the CCP component atlas generator that discovers AGENTS.md files
    in crate directories, parses invariants/contracts/extension points, and
    generates stable component IDs. The atlas provides the semantic inventory
    of the codebase that grounds all RFC file path references.

  files_to_modify: []

  files_to_create:
    - path: "crates/apm2-core/src/ccp/mod.rs"
      purpose: "CCP module root exporting component_atlas, crate_graph, and index submodules"
    - path: "crates/apm2-core/src/ccp/component_atlas.rs"
      purpose: "Component atlas generation: AGENTS.md discovery, parsing, and stable ID generation"

  implementation_steps:
    - step: 1
      action: "Create CCP module structure"
      details: |
        Create crates/apm2-core/src/ccp/mod.rs with:
        pub mod component_atlas;
        // pub mod crate_graph; (added in TCK-00112)
        // pub mod index; (added in TCK-00113)

        Re-export key types:
        pub use component_atlas::{ComponentAtlas, Component, Invariant, Contract, ExtensionPoint, CcpError};

    - step: 2
      action: "Define data structures"
      details: |
        In component_atlas.rs, define:

        pub struct ComponentAtlas {
            pub schema_version: String,
            pub generated_at: DateTime<Utc>,
            pub repo_root: PathBuf,
            pub components: Vec<Component>,
        }

        pub struct Component {
            pub id: String,           // COMP-{UPPER_SNAKE_CASE} from crate name
            pub name: String,         // Human-readable name
            pub crate_path: PathBuf,  // e.g., crates/apm2-core
            pub component_type: ComponentType,
            pub description: String,
            pub agents_md_path: Option<PathBuf>,
            pub invariants: Vec<Invariant>,
            pub contracts: Vec<Contract>,
            pub extension_points: Vec<ExtensionPoint>,
        }

        pub enum ComponentType { Library, Binary, XTask, Skill }

        pub struct Invariant { pub id: String, pub description: String }
        pub struct Contract { pub id: String, pub description: String }
        pub struct ExtensionPoint { pub id: String, pub description: String, pub stability: Stability }

    - step: 3
      action: "Implement AGENTS.md discovery"
      details: |
        fn discover_agents_md(repo_root: &Path) -> Vec<PathBuf>
        - Glob for crates/*/AGENTS.md and crates/*/*/AGENTS.md
        - Return sorted list of paths (for determinism)
        - Handle missing crates/ directory gracefully

    - step: 4
      action: "Implement AGENTS.md parsing"
      details: |
        fn parse_agents_md(path: &Path) -> Result<ParsedAgentsMd, CcpError>
        - Read file content
        - Extract invariants: lines matching /^INV-\d+:/ or markdown sections with INV- references
        - Extract contracts: lines matching /^CTR-\d+:/ or markdown sections with CTR- references
        - Extract extension points: sections marked with EXT- or "Extension Points" headers
        - Be tolerant of format variations (the file is markdown for humans)

        **Supported format variations (parser must handle all):**
        1. List format: `- INV-001: statement here`
        2. Definition format: `INV-001: statement here` (no leading dash)
        3. Header-prefixed: `### INV-001: Title\nstatement on next line`
        4. Table format: `| INV-001 | statement |`

        **Regex patterns for each format:**
        ```rust
        // Format 1 (List): captures id and statement
        let list_re = Regex::new(r"^-\s*(INV|CTR|EXT)-(\d+):\s*(.+)$").unwrap();

        // Format 2 (Definition): captures id and statement
        let def_re = Regex::new(r"^(INV|CTR|EXT)-(\d+):\s*(.+)$").unwrap();

        // Format 3 (Header): captures id and title, statement on next line
        let header_re = Regex::new(r"^#{1,4}\s*(INV|CTR|EXT)-(\d+):\s*(.+)$").unwrap();

        // Format 4 (Table): captures id and statement from markdown table row
        let table_re = Regex::new(r"^\|\s*(INV|CTR|EXT)-(\d+)\s*\|\s*(.+?)\s*\|").unwrap();
        ```

        **Sample AGENTS.md fixture for tests:**
        ```markdown
        # Component AGENTS.md

        ## Invariants
        - INV-001: All operations must be atomic
        INV-002: State is always consistent after operation

        ### INV-003: Thread Safety
        All public methods are thread-safe.

        | ID | Description |
        |----|-------------|
        | INV-004 | Memory usage bounded by config |

        ## Contracts
        - CTR-001: Caller must validate input before calling

        ## Extension Points
        - EXT-001: Custom handlers can be registered via trait
        ```

        If a format cannot be parsed, log warning and continue (graceful degradation).
        Parser tests should cover all four formats with sample AGENTS.md fixtures.

    - step: 5
      action: "Implement component ID generation"
      details: |
        fn generate_component_id(crate_name: &str) -> String
        - Convert crate name to UPPER_SNAKE_CASE
        - Prefix with "COMP-"
        - Example: "apm2-core" -> "COMP-APM2_CORE"
        - Must be deterministic and stable

    - step: 6
      action: "Implement build_component_atlas"
      details: |
        pub fn build_component_atlas(repo_root: &Path) -> Result<ComponentAtlas, CcpError>
        1. Discover all crate directories (parse workspace Cargo.toml or glob)
        2. For each crate, check for AGENTS.md
        3. If AGENTS.md exists, parse it; otherwise create placeholder entry
        4. Generate stable component ID from crate name
        5. Sort components by ID for determinism
        6. Return ComponentAtlas with schema_version and generated_at timestamp

  code_examples:
    - description: "Building a component atlas"
      code: |
        use apm2_core::ccp::build_component_atlas;
        use std::path::Path;

        let atlas = build_component_atlas(Path::new("/repo/root"))?;
        for component in &atlas.components {
            println!("{}: {} invariants, {} extension points",
                component.id,
                component.invariants.len(),
                component.extension_points.len());
        }

acceptance_criteria:
  - criterion: "Component IDs are stable across runs"
    verification: "Unit test runs build_component_atlas twice on same repo - component IDs must match exactly"
  - criterion: "AGENTS.md invariants are correctly extracted"
    verification: "Unit test with sample AGENTS.md containing INV-001, INV-002 - verify both extracted with correct descriptions"
  - criterion: "Components without AGENTS.md get placeholder entries"
    verification: "Unit test with crate lacking AGENTS.md - verify component created with empty invariants/contracts/extension_points"

test_requirements:
  - test_id: UT-111-01
    description: "Test component ID generation is deterministic"
    verification_command: "cargo test -p apm2-core ccp::component_atlas::tests::test_component_id_deterministic"
  - test_id: UT-111-02
    description: "Test AGENTS.md discovery finds all files"
    verification_command: "cargo test -p apm2-core ccp::component_atlas::tests::test_agents_md_discovery"
  - test_id: UT-111-03
    description: "Test AGENTS.md parsing extracts invariants"
    verification_command: "cargo test -p apm2-core ccp::component_atlas::tests::test_parse_invariants"
  - test_id: UT-111-04
    description: "Test AGENTS.md parsing extracts extension points"
    verification_command: "cargo test -p apm2-core ccp::component_atlas::tests::test_parse_extension_points"
  - test_id: UT-111-05
    description: "Test placeholder components for crates without AGENTS.md"
    verification_command: "cargo test -p apm2-core ccp::component_atlas::tests::test_placeholder_components"
  - test_id: IT-111-01
    description: "Integration test: full component atlas build"
    verification_command: "cargo test -p apm2-core ccp::component_atlas"

notes: |
  The component atlas is the semantic foundation of the CCP. It captures what
  each crate promises (invariants), expects (contracts), and exposes (extension
  points). This information is used by Impact Map generation to determine where
  new requirements should be implemented.

  AGENTS.md parsing should be tolerant - these files are primarily documentation
  for human agents, so the parser should extract what it can and not fail on
  unexpected formatting.

  Blocked by TCK-00110 because component atlas output must use canonical YAML
  from the determinism module to ensure stable, reproducible outputs.
