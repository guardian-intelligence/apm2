schema_version: "2026-01-26"
template_version: "2026-01-26"

ticket:
  id: TCK-00119
  title: "Implement run manifest with signing"
  status: READY
  rfc_id: RFC-0010
  requirement_ids:
    - REQ-0009
    - REQ-0012
  depends_on:
    - TCK-00118

implementation:
  summary: |
    Create the run manifest module to generate cryptographically signed records
    of pipeline execution. Manifests capture input/output hashes, routing decisions,
    stage timings, and are signed with Ed25519 to enable verification and
    reproducibility auditing.

  files_to_create:
    - path: "crates/apm2-core/src/run_manifest/mod.rs"
      purpose: "Module entry point exposing manifest and signer submodules"

    - path: "crates/apm2-core/src/run_manifest/manifest.rs"
      purpose: "RunManifest struct with all required fields and serialization"

    - path: "crates/apm2-core/src/run_manifest/signer.rs"
      purpose: "Ed25519 signing and verification using existing crypto module"

  files_to_modify:
    - path: "crates/apm2-core/src/lib.rs"
      changes: "Add pub mod run_manifest declaration"

  implementation_steps:
    - step: 1
      action: "Define manifest structure"
      details: |
        In manifest.rs:
        - RunManifest struct with fields:
          - manifest_id: UUID v7 for temporal ordering
          - lease_id: identifies the pipeline execution session
          - created_at: ISO 8601 timestamp
          - input_hashes: map of input artifact paths to BLAKE3 hashes
          - output_hashes: map of output artifact paths to BLAKE3 hashes
          - routing_profile_id: which profile was used
          - routing_decisions: map of stage to provider used
          - stage_timings: map of stage to duration_ms
          - ccp_index_hash: hash of CCP index used as grounding
        - Implement Serialize/Deserialize

        **UUID v7 generation:**
        Use the `uuid` crate with `v7` feature:
        ```toml
        # In Cargo.toml
        uuid = { version = "1.0", features = ["v7"] }
        ```
        ```rust
        use uuid::Uuid;
        let manifest_id = Uuid::now_v7().to_string();
        ```

    - step: 2
      action: "Implement manifest builder"
      details: |
        In manifest.rs:
        - ManifestBuilder with fluent API
        - Methods: with_lease_id, add_input, add_output, record_stage_timing
        - build() validates all required fields present

    - step: 3
      action: "Implement signer"
      details: |
        In signer.rs:
        - Reuse existing crypto module for Ed25519 operations
        - sign_manifest(manifest, signing_key) -> SignedManifest
        - SignedManifest includes manifest bytes and signature
        - Canonicalize manifest before signing (deterministic JSON)

    - step: 4
      action: "Implement verifier"
      details: |
        In signer.rs:
        - verify_manifest(signed_manifest, public_key) -> Result<RunManifest>
        - Verify signature matches manifest bytes
        - Verify all hash fields match expected values when verifying against artifacts
        - Return error on any mismatch

    - step: 5
      action: "Wire up module"
      details: |
        In mod.rs and lib.rs:
        - Export RunManifest, ManifestBuilder, SignedManifest
        - Export sign_manifest, verify_manifest functions

  code_examples:
    - description: "Manifest structure example"
      code: |
        # Example run manifest (unsigned)
        manifest_id: "019450a8-b2c4-7000-8000-000000000001"
        lease_id: "lease-2026-01-26-001"
        created_at: "2026-01-26T14:30:00Z"
        input_hashes:
          "documents/prds/PRD-0005/00_meta.yaml": "blake3:abc123..."
          "documents/prds/PRD-0005/requirements/REQ-0001.yaml": "blake3:def456..."
        output_hashes:
          "evidence/prd/PRD-0005/ccp/ccp_index.json": "blake3:789xyz..."
          "documents/rfcs/RFC-0010/00_meta.yaml": "blake3:uvw012..."
        routing_profile_id: "local"
        routing_decisions:
          ccp_build: "local"
          impact_map: "anthropic/claude-3-5-sonnet"
          rfc_frame: "anthropic/claude-3-5-sonnet"
        stage_timings:
          ccp_build: 2340
          impact_map: 45230
          rfc_frame: 67890
        ccp_index_hash: "blake3:abc123..."

acceptance_criteria:
  - criterion: "Manifests include all required fields"
    verification: "Unit tests verify ManifestBuilder enforces required fields and serialization includes all fields"

  - criterion: "Ed25519 signatures verify correctly"
    verification: "Round-trip tests sign then verify manifests successfully"

  - criterion: "Verification fails on hash mismatch"
    verification: "Tests with tampered hashes fail verification with specific error"

test_requirements:
  - test_id: UT-119-01
    description: "Test manifest builder validates required fields"
    verification_command: "cargo test -p apm2-core run_manifest::manifest::builder"

  - test_id: UT-119-02
    description: "Test manifest serialization roundtrip"
    verification_command: "cargo test -p apm2-core run_manifest::manifest::serde"

  - test_id: UT-119-03
    description: "Test Ed25519 sign and verify roundtrip"
    verification_command: "cargo test -p apm2-core run_manifest::signer::roundtrip"

  - test_id: UT-119-04
    description: "Test verification fails on tampered manifest"
    verification_command: "cargo test -p apm2-core run_manifest::signer::tamper"

  - test_id: UT-119-05
    description: "Test verification fails on hash mismatch"
    verification_command: "cargo test -p apm2-core run_manifest::signer::hash_mismatch"

notes: |
  This ticket implements REQ-0009 (reproducibility via manifests) and REQ-0012
  (cryptographic signing) from RFC-0010.

  Key design decisions:
  - Manifests use UUID v7 for manifest_id to enable temporal ordering.
  - BLAKE3 is used for content hashing (consistent with determinism module).
  - Ed25519 signing reuses the existing crypto module infrastructure.
  - Manifests are canonicalized (sorted keys, consistent formatting) before
    signing to ensure deterministic signatures.

  CCP grounding: COMP-CORE module, depends on TCK-00118 (model router) for
  routing decision capture.
