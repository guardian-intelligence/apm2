---
name: gemini-cli
description: CLI reference for Gemini command-line interface. Use when you need help with Gemini CLI commands, flags, or CLI usage.
user-invocable: true
disable-model-invocation: false
---


Gemini CLI is implemented as a **Node.js (≥20) ESM** application packaged as a TypeScript **workspace monorepo** (`@google/gemini-cli`, `type: "module"`) with a dual distribution model: a development/workspace entry (`packages/cli/dist/index.js`) and a published, **esbuild-bundled** production entry (`bin.gemini → bundle/gemini.js` per root `package.json`). The repository is organized into a thin interactive shell (`packages/cli`) and an execution substrate (`packages/core`), with additional integration surfaces (`packages/a2a-server`, `packages/vscode-ide-companion`). This separation is not cosmetic: the CLI is effectively a terminal UI and argument front-end over a core “agent runtime” that encapsulates model invocation, tool mediation, policy, persistence, extensions, and telemetry.

At process startup (`packages/cli/src/gemini.tsx`), Gemini CLI establishes fail-fast failure semantics (explicit handlers for `unhandledRejection`, debug-console escalation) and implements a self-reexec mechanism to normalize heap sizing. The heap relaunch logic (`getNodeMemoryArgs`) computes a target `--max-old-space-size` proportional to host RAM (50% of total memory) and re-execs unless suppressed by `GEMINI_CLI_NO_RELAUNCH`, thereby making runtime memory behavior partially a function of the host machine. The UI runtime is Ink/React-based (`ink` rendering to TTY), with explicit terminal-mode control (alternate screen selection, mouse event enablement, cursor/line-wrapping policies) and accessibility gating (e.g., disabling alternate buffer semantics when screen reader mode is enabled).

The command-line surface is specified in `packages/cli/src/config/config.ts` via `yargs`, with a first-order bifurcation between **interactive** and **headless** execution. Interactive mode is the default for TTY contexts; headless execution is forced via `--prompt/-p` and emits deterministic output modes (`--output-format ∈ {text,json,stream-json}`) aligned with machine consumption (`packages/core/src/output/types.ts` defines structured JSON and streaming event schemas). Approval and tool-governance semantics are first-class CLI inputs (`--approval-mode ∈ {default,auto_edit,yolo,plan}` plus legacy `--yolo`), and the CLI intentionally constrains tool availability in headless mode to prevent hangs by filtering tools that require user interaction (`createToolExclusionFilter`, with special-case handling for the shell tool family).

The execution kernel is the `Config` composition object in `packages/core/src/config/config.ts`, which binds together the model client stack (`createContentGenerator`, `GeminiClient`, `BaseLlmClient`, `ModelRouterService`), context ingestion (`FileDiscoveryService`, `ContextManager`), tool mediation (`ToolRegistry` and individual tool implementations), policy enforcement (`PolicyEngine` + confirmation bus), agent/skill systems (`AgentRegistry`, `SkillManager`, subagent tooling), extension/MCP integration, and telemetry. Config construction is parameterized by a large `ConfigParameters` surface, reflecting that “runtime posture” is determined by an aggregate of CLI flags, workspace settings, system settings, and environment variables rather than by a single configuration file.

Tooling is implemented as an explicit syscall-like boundary: the model generates tool call intents which are validated and executed by the runtime rather than directly by the model. Tool naming and syntactic validation are centralized (`packages/core/src/tools/tool-names.ts`), including a strict naming convention for MCP tools (`server__tool`) and explicit “plan mode” read-only tool sets (`PLAN_MODE_TOOLS`). Built-in tools span filesystem inspection, editing primitives, shell execution, and network fetch/search, with output truncation controls and summarization budgets available at the config layer (e.g., `truncateToolOutputThreshold/Lines`, `summarizeToolOutput`). This architecture makes mediated side effects and tool provenance structurally observable, enabling both interactive approvals and automated policy gating.

Policy is expressed as a tiered, precedence-aware rule system loaded from TOML and augmented by dynamic rules. The policy configuration module (`packages/core/src/policy/config.ts`) defines a deterministic tier hierarchy—**Default (core) < User (home) < Admin (system)**—and maps each tier to a priority band to guarantee `Admin > User > Default` dominance regardless of intra-tier rule priorities. Policy directories are resolved via the `Storage` abstraction (`DEFAULT_CORE_POLICIES_DIR`, `~/.gemini/policies`, `/etc/gemini-cli/policies` by default), and CLI/settings-derived rules are injected at fixed priorities (e.g., persistent MCP exclusions, explicit tool allow/deny sets, trusted MCP server allowances). Approval modes translate into policy decisions, with `plan` acting as a read-only posture, and “YOLO” acting as a universal allow posture unless explicitly disabled (`disableYoloMode` in core config).

Persistent state is specified as a layered filesystem model via `packages/core/src/config/storage.ts` and `packages/core/src/utils/paths.ts`. The global control root is `~/.gemini` (overrideable via `GEMINI_CLI_HOME`), with system-wide overrides under `/etc/gemini-cli/settings.json` (or platform-specific equivalents) and project-scoped configuration under `<repo>/.gemini/`. Runtime working state is stored in a hashed project temp directory (`~/.gemini/tmp/<sha256(projectRoot)>/`) to provide isolation by workspace identity while avoiding pollution of repository working trees. This layout encompasses session records, checkpoints, logs, and shell history, enabling resumability (`--resume`, `--list-sessions`, `--delete-session`) without coupling session identity to process lifetime.

Session capture is a first-class substrate feature rather than an incidental logging mechanism. The chat recording subsystem (`packages/core/src/services/chatRecordingService.ts`) persists structured JSON session files containing user/assistant messages, tool call envelopes and results, token usage breakdowns, and thought summaries where present. The recorder explicitly handles resource exhaustion (disk full) by disabling recording while continuing the interactive run (`ENOSPC` is treated as a non-fatal degradation), which is an operationally relevant behavior on constrained systems. This yields a durable audit trail of interaction and tool usage suitable for downstream replay/inspection even when the terminal UI is ephemeral.

Extensibility is specified via a multi-channel capability injection system: extensions, skills, hooks, agents, and MCP servers. Extensions are managed by the CLI-side `ExtensionManager` (`packages/cli/src/config/config.ts` loads and activates extensions, gating consent and setting prompts) and represented in core by a structured `GeminiCLIExtension` descriptor that can bundle MCP server definitions, context files, hook definitions, skill definitions, and agent definitions. Hooks and skills are conditionally activated by settings and CLI commands (e.g., hooks command registration is gated by `settings.tools.enableHooks`). This makes “capabilities” explicitly declarative and scope-aware rather than ad hoc runtime mutation.

MCP integration is treated as a transport-agnostic tool plane with multiple supported transports and an explicit trust model. MCP server configuration (`MCPServerConfig` in `packages/core/src/config/config.ts`) supports stdio execution (`command/args/env/cwd`), server-sent events and streamable HTTP (`url` + `type ∈ {sse,http}`), and TCP/websocket-style endpoints (`tcp`), with per-server tool include/exclude filters and optional OAuth configuration. OAuth token persistence is implemented as a hybrid storage system (`packages/core/src/mcp/token-storage/*`): a keychain-backed store (via `keytar`) when available and a deterministic encrypted file store otherwise. The file store (`file-token-storage.ts`) uses AES-256-GCM with an scrypt-derived key (host/user-bound salt), writes to `~/.gemini/mcp-oauth-tokens-v2.json`, and treats authentication failures as corruption. This design makes token storage behavior on Linux hosts contingent on system keyring availability, with explicit control via `GEMINI_FORCE_FILE_STORAGE`.

Operationally, the CLI includes an optional sandbox execution plane implemented as a wrapper around container runtimes (`packages/cli/src/utils/sandbox.ts`), with Linux support via Docker/Podman (`SandboxConfig.command ∈ {docker,podman}`) and macOS via Seatbelt (`sandbox-exec`). On Ubuntu-class systems, sandbox posture therefore reduces to container runtime availability, image resolution, and runtime permissions; the CLI can also build or substitute sandbox images under controlled conditions (notably when running from a linked repository checkout). Separately from sandboxing, Gemini CLI provides additional under-the-hood control planes that materially affect runtime semantics: environment-variable overrides for home/system paths (`GEMINI_CLI_HOME`, `GEMINI_CLI_SYSTEM_SETTINGS_PATH`), proxying (`HTTP(S)_PROXY` handling via `setGlobalProxy`), debug/telemetry sinks, and centrally fetched admin controls for code-assist deployments (`packages/core/src/code_assist/admin/admin_controls.ts` polls and applies sanitized remote settings under experiment gating). In aggregate, the Gemini CLI specification is best understood as a layered agent runtime whose behavior is the deterministic composition of (a) CLI flags, (b) workspace/user/system settings, (c) tiered policy rules, and (d) optional remote administrative controls, all mediated through a tool-execution boundary and a persistent session/evidence substrate.
