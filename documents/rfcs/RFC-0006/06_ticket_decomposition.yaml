rfc_ticket_decomposition:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"

  decomposition_strategy: |
    Phased implementation with dependency ordering:
    - Phase 0: Documentation (parallel, no dependencies)
    - Phase 1: Local checks (parallel, no dependencies)
    - Phase 2: Test coverage (parallel, no dependencies)
    - Phase 3: Workflow improvements (dependencies on earlier phases)

  phases:
    - phase: 0
      name: "Documentation & Guidelines"
      description: "Capture learned anti-patterns and historical issue patterns"
      tickets:
        - ticket_id: "TCK-00059"
          title: "Add Learned Anti-Patterns to Coding Guidelines"
          requirements:
            - "MAINT-006"
          dependencies: []
          scope_summary: |
            Update coding guidelines with anti-patterns discovered during PR #58 and #59:

            Files to modify:
            - documents/skills/coding/references/SAFE_RUST_PATTERNS.md
            - documents/skills/coding/SKILL.md (add reference to anti-patterns section)

            Add "Anti-Patterns (Lessons Learned)" section:
            - ANTI-1: Shell argument escaping for complex strings
              Problem: Passing markdown/complex prompts as CLI arguments
              Solution: Write to temp file and redirect input
            - ANTI-2: Predictable temp file names
              Problem: std::env::temp_dir().join("fixed_name.txt")
              Solution: Use tempfile::NamedTempFile
            - ANTI-3: Incomplete struct field updates
              Problem: Adding struct fields without updating all pattern matches
              Solution: Use .. to ignore unmatched fields, run cargo check

            Add SAFE-16: Restart Monotonicity pattern
            - Invariant: new_restart_attempt > old_restart_attempt (unless terminal)
            - Implementation: Check in reducer before state transition

            Acceptance Criteria:
            - Anti-patterns section exists with 3 documented patterns
            - SAFE-16 pattern exists for restart monotonicity
            - Referenced from main SKILL.md

        - ticket_id: "TCK-00060"
          title: "Add Historical Issue Patterns to Security Review Prompt"
          requirements:
            - "MAINT-008"
          dependencies: []
          scope_summary: |
            Update security review prompt with historical issue patterns:

            Files to modify:
            - documents/reviews/SECURITY_REVIEW_PROMPT.md

            Add "Historical Issue Patterns (Check First)" section:
            1. State machine restart logic patterns
               - Verify restart_attempt monotonicity
               - Check terminal state transitions
               - Validate session ID handling on restart
            2. Temp file handling patterns
               - Check for std::env::temp_dir usage
               - Verify 0600 permissions
               - Check cleanup on error paths
            3. Shell/process spawning patterns
               - Check for shell interpolation with user data
               - Verify argument escaping for multi-word strings
               - Check for script command usage for PTY
            4. Struct field addition patterns
               - Verify all pattern matches updated
               - Check for missing fields in constructors
               - Verify serialization/deserialization coverage

            Acceptance Criteria:
            - Prompt includes historical patterns section
            - Patterns derived from actual findings in PR #58 and #59

    - phase: 1
      name: "Enhanced Local Checks"
      description: "Improve pre-commit checks and add automated pattern validation"
      tickets:
        - ticket_id: "TCK-00061"
          title: "Enhance Pre-Commit Clippy Lints"
          requirements:
            - "MAINT-007"
          dependencies: []
          scope_summary: |
            Enhance clippy lints in the commit command:

            Files to modify:
            - xtask/src/tasks/commit.rs

            Changes:
            1. Add explicit clippy lints to the clippy invocation:
               - -D clippy::doc_markdown (catch missing backticks)
               - -D clippy::match_same_arms (catch redundant arms)
               - -W clippy::missing_const_for_fn (suggest const)

            2. Add tip about `..` in match patterns:
               Display: "Tip: Use `..` to ignore unmatched struct fields in patterns"

            Acceptance Criteria:
            - Pre-commit catches doc-markdown warnings
            - Pre-commit catches match-same-arms warnings
            - Tip displayed during clippy check

        - ticket_id: "TCK-00062"
          title: "Add Automated Pattern Validation"
          requirements:
            - "MAINT-012"
          dependencies: []
          scope_summary: |
            Create new cargo xtask lint command for anti-pattern detection:

            Files to create:
            - xtask/src/tasks/lint.rs (new)

            Files to modify:
            - xtask/src/tasks/mod.rs (add lint module)
            - xtask/src/main.rs (add lint subcommand)

            Implementation:
            1. Create LintArgs struct with optional --fix flag
            2. Implement anti-pattern checks:
               - Check for direct std::env::temp_dir usage
                 Pattern: r"std::env::temp_dir\(\)"
                 Warning: "Use tempfile::NamedTempFile instead"
               - Check for shell interpolation patterns
                 Pattern: r"Command::new.*args.*\{.*\}" with markdown content
                 Warning: "Write prompts to temp file and redirect input"
            3. Report warnings (not errors) for anti-patterns
            4. Return success even with warnings

            Acceptance Criteria:
            - cargo xtask lint catches temp file anti-patterns
            - cargo xtask lint catches shell interpolation anti-patterns
            - Warnings issued but command succeeds

    - phase: 2
      name: "Test Coverage"
      description: "Add boundary tests for restart logic and AI tool invocation"
      tickets:
        - ticket_id: "TCK-00063"
          title: "Add Restart Monotonicity Boundary Tests"
          requirements:
            - "MAINT-009"
          dependencies: []
          scope_summary: |
            Add boundary tests for restart_attempt monotonicity:

            Files to modify:
            - crates/apm2-core/src/session/reducer.rs (add tests)

            Test cases:
            1. test_restart_monotonicity_boundary_cases
               - restart_attempt 0 -> 0: MUST FAIL
               - restart_attempt 0 -> 1: MUST succeed
               - restart_attempt 5 -> 5: MUST FAIL
               - restart_attempt 5 -> 6: MUST succeed
               - restart_attempt u32::MAX -> any: MUST FAIL (overflow)

            2. test_restart_preserves_terminal_state_data
               - Verify last_restart_attempt preserved in terminal states
               - Verify resume_cursor preserved in terminal states
               - Verify error context preserved in Crashed state

            Acceptance Criteria:
            - cargo test test_restart_monotonicity_boundary_cases passes
            - cargo test test_restart_preserves_terminal_state_data passes

        - ticket_id: "TCK-00064"
          title: "Add AI Tool Invocation Tests"
          requirements:
            - "MAINT-010"
          dependencies: []
          scope_summary: |
            Add tests for AI tool invocation patterns:

            Files to modify:
            - xtask/src/tasks/push.rs (add tests)
            - xtask/src/tasks/review.rs (add tests)

            Test cases:
            1. test_temp_file_security
               - Create NamedTempFile and verify permissions are 0600
               - Verify file path is unpredictable (not in fixed location)
               - Verify file is cleaned up after drop

            2. test_script_command_format
               - Verify script command format is valid
               - Verify input redirection syntax
               - Verify PTY allocation via script

            Acceptance Criteria:
            - cargo test -p xtask test_temp_file_security passes
            - cargo test -p xtask test_script_command_format passes

    - phase: 3
      name: "Workflow Improvements"
      description: "Improve error messages and switch to Gemini for code quality"
      tickets:
        - ticket_id: "TCK-00065"
          title: "Improve Check Workflow Error Messages"
          requirements:
            - "MAINT-011"
          dependencies:
            - "TCK-00061"
          scope_summary: |
            Add failure-type-specific remediation commands:

            Files to modify:
            - xtask/src/tasks/check.rs

            Add remediation mapping:
            - Clippy failure: "Run: cargo clippy --fix --allow-dirty"
            - Fmt failure: "Run: cargo fmt"
            - Test failure: "Run: cargo test --workspace"
            - SecurityReview failure: "Run: cargo xtask push --force-review"
            - QualityReview failure: "Run: cargo xtask push --force-review"
            - SemverCheck failure: "Run: cargo semver-checks"

            Display format:
            ```
            [X] Clippy checks failed
                Fix: cargo clippy --fix --allow-dirty
            ```

            Acceptance Criteria:
            - cargo xtask check shows specific fix commands for each failure type

        - ticket_id: "TCK-00066"
          title: "Switch Code Quality Reviewer to Gemini CLI"
          requirements:
            - "MAINT-013"
          dependencies:
            - "TCK-00064"
          scope_summary: |
            Replace Codex with Gemini CLI for code quality review:

            Files to modify:
            - xtask/src/tasks/push.rs
            - xtask/src/tasks/review.rs

            Changes:
            1. Update ReviewType::Quality.ai_tool() to return "gemini" (line 64 in review.rs, in the ai_tool() method)
            2. Replace Codex invocation with Gemini CLI pattern:

            Current (review.rs lines 304-331, in the ReviewType::Quality match arm):
            ```rust
            ReviewType::Quality => {
                // Codex uses the 'review' subcommand to review changes against base branch.
                // The review subcommand runs non-interactively by default.
                let result = std::process::Command::new("codex")
                    .args(["review", "--base", "main"])
                    .status();
                // ... error handling ...
            }
            ```

            After (same pattern as security review, lines 261-282):
            ```rust
            let result = NamedTempFile::new().and_then(|mut temp_file| {
                temp_file.write_all(prompt.as_bytes())?;
                let prompt_path = temp_file.path().display().to_string();
                let shell_cmd =
                    format!("script -qec \"gemini --yolo < '{prompt_path}'\" /dev/null");
                std::process::Command::new("sh")
                    .args(["-c", &shell_cmd])
                    .status()
            });
            ```

            3. Ensure CODE_QUALITY_PROMPT.md exists at documents/reviews/CODE_QUALITY_PROMPT.md
               (referenced by review.rs line 55; create if missing with code quality review criteria)
            4. Update doc comment on ReviewType::Quality (line 26-27) to say:
               "Code quality review using Gemini and `CODE_QUALITY_PROMPT.md`"
               (was: "Code quality review using Codex and `CODE_QUALITY_PROMPT.md`")
            5. Update push.rs trigger_ai_reviews() (lines 345-357) to use Gemini pattern for quality:
               - Replace codex check with gemini check (both already use gemini_available)
               - Use same temp file + script pattern as security review

            Acceptance Criteria:
            - cargo xtask review quality <PR_URL> uses Gemini CLI
            - cargo xtask push triggers Gemini for code quality review
            - Code quality review posts comment and updates status

        - ticket_id: "TCK-00067"
          title: "Add Reviewer Agent Health Monitoring"
          requirements:
            - "MAINT-014"
          dependencies:
            - "TCK-00066"
          scope_summary: |
            Add health monitoring for AI reviewer agents to the check command:

            Files to create:
            - xtask/src/reviewer_state.rs (new module for state management)

            Files to modify:
            - xtask/src/tasks/check.rs (add health monitoring display and auto-remediation)
            - xtask/src/tasks/push.rs (write state on spawn, redirect output to log)
            - xtask/src/tasks/review.rs (write state on spawn, redirect output to log)
            - xtask/src/main.rs (add reviewer_state module)

            Dependencies to add (xtask/Cargo.toml):
            - chrono = { workspace = true } (already present)
            - nix = { workspace = true } (must add - for kill syscall; available in workspace)
            - directories = { workspace = true } (must add - for home_dir; available in workspace as "directories")

            Implementation:

            1. Create reviewer_state.rs module with types:
               ```rust
               use chrono::{DateTime, Utc};
               use serde::{Deserialize, Serialize};
               use std::collections::HashMap;
               use std::path::PathBuf;

               #[derive(Debug, Clone, Serialize, Deserialize)]
               pub struct ReviewerEntry {
                   pub pid: u32,
                   pub started_at: DateTime<Utc>,
                   pub log_file: PathBuf,
                   pub pr_url: String,
                   pub head_sha: String,
               }

               #[derive(Debug, Clone, Copy, PartialEq, Eq)]
               pub enum HealthStatus {
                   Healthy,
                   Stale,
                   Dead,
               }

               #[derive(Debug, Default, Serialize, Deserialize)]
               pub struct ReviewerStateFile {
                   pub reviewers: HashMap<String, ReviewerEntry>,
               }
               ```

            2. Implement state file operations:
               ```rust
               impl ReviewerStateFile {
                   pub fn path() -> PathBuf {
                       directories::BaseDirs::new()
                           .expect("home dir")
                           .home_dir()
                           .join(".apm2")
                           .join("reviewer_state.json")
                   }

                   pub fn load() -> Result<Self> {
                       let path = Self::path();
                       if !path.exists() {
                           return Ok(Self::default());
                       }
                       let content = std::fs::read_to_string(&path)?;
                       Ok(serde_json::from_str(&content)?)
                   }

                   pub fn save(&self) -> Result<()> {
                       let path = Self::path();
                       // Ensure parent directory exists with 0700 permissions
                       if let Some(parent) = path.parent() {
                           std::fs::create_dir_all(parent)?;
                           #[cfg(unix)]
                           {
                               use std::os::unix::fs::PermissionsExt;
                               std::fs::set_permissions(parent,
                                   std::fs::Permissions::from_mode(0o700))?;
                           }
                       }
                       // Atomic write: temp file -> rename
                       let temp_path = path.with_extension("tmp");
                       std::fs::write(&temp_path, serde_json::to_string_pretty(self)?)?;
                       std::fs::rename(&temp_path, &path)?;
                       Ok(())
                   }
               }
               ```

            3. Implement health checking:
               ```rust
               impl ReviewerEntry {
                   pub fn check_health(&self) -> HealthStatus {
                       // Check if process is alive
                       #[cfg(unix)]
                       {
                           use nix::sys::signal::{kill, Signal};
                           use nix::unistd::Pid;
                           let alive = kill(Pid::from_raw(self.pid as i32), None).is_ok();
                           if !alive {
                               return HealthStatus::Dead;
                           }
                       }

                       // Check log file mtime for last activity
                       if let Ok(metadata) = std::fs::metadata(&self.log_file) {
                           if let Ok(mtime) = metadata.modified() {
                               let elapsed = mtime.elapsed().unwrap_or_default();
                               if elapsed.as_secs() >= 60 {
                                   return HealthStatus::Stale;
                               }
                           }
                       }
                       HealthStatus::Healthy
                   }
               }
               ```

            4. Update review spawn (push.rs, review.rs) to:
               a. Create NamedTempFile for log capture (keep reference to prevent deletion)
               b. Use script command with log capture:
                  ```rust
                  let log_file = tempfile::Builder::new()
                      .prefix("apm2_review_security_")
                      .suffix(".log")
                      .tempfile()?;
                  let log_path = log_file.path().to_owned();

                  let child = Command::new("script")
                      .args(["-q", &log_path.display().to_string(), "-c",
                             &format!("gemini --yolo < '{}'", prompt_path.display())])
                      .spawn()?;

                  // Record in state file
                  let mut state = ReviewerStateFile::load()?;
                  state.reviewers.insert("security".to_string(), ReviewerEntry {
                      pid: child.id(),
                      started_at: Utc::now(),
                      log_file: log_path,
                      pr_url: pr_url.to_string(),
                      head_sha: head_sha.to_string(),
                  });
                  state.save()?;

                  // Keep log_file handle to prevent cleanup until process exits
                  std::mem::forget(log_file);
                  ```

            5. Update check command (check.rs) to:
               a. Load ReviewerStateFile
               b. Display health status for each reviewer
               c. Trigger auto-remediation for STALE or DEAD reviewers

               Auto-remediation flow:
               ```rust
               /// Remediate a stale or dead reviewer by killing and restarting.
               ///
               /// The PR URL and HEAD SHA are read from the ReviewerEntry in the state file,
               /// which were saved when the reviewer was originally spawned. This allows
               /// restarting the same review without needing to query GitHub again.
               fn remediate_reviewer(
                   sh: &Shell,
                   name: &str,
                   entry: &ReviewerEntry,
                   state: &mut ReviewerStateFile,
               ) -> Result<()> {
                   let elapsed_secs = entry.log_file
                       .metadata().ok()
                       .and_then(|m| m.modified().ok())
                       .and_then(|t| t.elapsed().ok())
                       .map_or(0, |d| d.as_secs());

                   println!("[!] {} reviewer stale ({}s since last activity)",
                            name, elapsed_secs);
                   println!("    Auto-remediating: killing PID {} and restarting review...",
                            entry.pid);

                   // Kill process (SIGTERM, then SIGKILL after 5s)
                   #[cfg(unix)]
                   {
                       use nix::sys::signal::{kill, Signal};
                       use nix::unistd::Pid;
                       let pid = Pid::from_raw(entry.pid as i32);
                       let _ = kill(pid, Signal::SIGTERM);

                       // Poll for exit with 100ms intervals, up to 5s
                       for _ in 0..50 {
                           std::thread::sleep(Duration::from_millis(100));
                           if kill(pid, None).is_err() {
                               break; // Process exited
                           }
                       }

                       // Force kill if still alive
                       let _ = kill(pid, Signal::SIGKILL);
                   }

                   // Clean up old log file
                   let _ = std::fs::remove_file(&entry.log_file);

                   // Remove old entry from state file before restarting
                   state.reviewers.remove(name);
                   state.save()?;

                   // Re-trigger review using saved PR URL and HEAD SHA from state file
                   // This calls the same spawn_review() function used by push.rs
                   let new_pid = spawn_review(
                       sh,
                       &entry.pr_url,
                       &entry.head_sha,
                       name,  // "security" or "quality"
                   )?;

                   println!("    Restarted {} review (new PID: {})", name, new_pid);

                   Ok(())
               }
               ```

            6. Handle edge cases:
               - State file missing: treat as no active reviewers
               - State file corrupt (invalid JSON): log warning, delete, start fresh
               - PID reuse: check if /proc/<pid>/cmdline contains "gemini" or "script"
               - Multiple check commands: use file locking (flock) during remediation
               - Log file deleted: treat as stale (cannot verify activity)
               - Both reviewers stale simultaneously: remediate sequentially (security first, then quality)
                 to avoid overwhelming system resources; log each remediation separately
               - Log file cleanup on success: when review completes successfully (AI posts comment
                 and updates status), delete log file in finish/cleanup code; on remediation,
                 delete old log file before restarting

            Acceptance Criteria:
            - check command displays reviewer health section
            - Health shows PID, last activity timestamp, status for each reviewer
            - Stale reviewers (>60s) are automatically killed and restarted
            - Remediation logged to user
            - State persisted in ~/.apm2/reviewer_state.json
            - Atomic state file writes prevent corruption
            - Graceful handling of missing/corrupt state files

  dependency_graph: |
    Phase 0 (Documentation) - No dependencies:
    ┌─────────────┐  ┌─────────────┐
    │  TCK-00059  │  │  TCK-00060  │
    │ anti-       │  │ historical  │
    │ patterns    │  │ patterns    │
    └─────────────┘  └─────────────┘

    Phase 1 (Local Checks) - No dependencies:
    ┌─────────────┐  ┌─────────────┐
    │  TCK-00061  │  │  TCK-00062  │
    │ clippy      │  │ xtask lint  │
    │ lints       │  │ command     │
    └──────┬──────┘  └─────────────┘
           │
           │ depends on
           ▼
    Phase 3:
    ┌─────────────┐
    │  TCK-00065  │
    │ check       │
    │ remediation │
    └─────────────┘

    Phase 2 (Test Coverage) - No dependencies:
    ┌─────────────┐  ┌─────────────┐
    │  TCK-00063  │  │  TCK-00064  │
    │ restart     │  │ AI tool     │
    │ monotonicity│  │ invocation  │
    └─────────────┘  └──────┬──────┘
                            │
                            │ depends on
                            ▼
                     ┌─────────────┐
                     │  TCK-00066  │
                     │ Gemini      │
                     │ switch      │
                     └──────┬──────┘
                            │
                            │ depends on
                            ▼
                     ┌─────────────┐
                     │  TCK-00067  │
                     │ reviewer    │
                     │ health      │
                     └─────────────┘

  impact_summary:
    - ticket: "TCK-00059"
      issues_prevented: ["A1", "A2", "A3", "B1", "B2", "B3"]
      impact: "Knowledge capture prevents recurrence"

    - ticket: "TCK-00060"
      issues_prevented: ["B1", "B2", "B3"]
      impact: "Faster security review (known patterns)"

    - ticket: "TCK-00061"
      issues_prevented: ["C1", "C2", "C3"]
      impact: "Catches lint issues locally"

    - ticket: "TCK-00062"
      issues_prevented: ["A2", "A3"]
      impact: "Automated anti-pattern detection"

    - ticket: "TCK-00063"
      issues_prevented: ["B3"]
      impact: "Prevents regression of monotonicity"

    - ticket: "TCK-00064"
      issues_prevented: ["A1", "A2", "A3"]
      impact: "Prevents regression of temp file issues"

    - ticket: "TCK-00065"
      issues_prevented: ["All"]
      impact: "Faster fix iteration"

    - ticket: "TCK-00066"
      issues_prevented: []
      impact: "Unified AI reviewer (Gemini for both)"

    - ticket: "TCK-00067"
      issues_prevented: ["A1"]
      impact: "Automatic detection and recovery from stale/crashed reviewers"

  expected_outcomes:
    - "80% fewer review iterations on state machine changes"
    - "Zero recurrence of temp file/shell escaping issues"
    - "Pre-commit catches 95% of lint issues before push"
    - "Unified AI reviewer simplifies tooling"
    - "Stale reviewers auto-remediated within 60s of detection"
