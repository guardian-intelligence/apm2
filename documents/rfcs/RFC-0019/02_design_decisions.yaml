rfc_design_decisions:
  schema_version: "2026-01-23"
  template_version: "2026-01-23"
  decisions:
    - id: "DEC-0001"
      title: "Session dispatcher wiring strategy"
      statement: "SessionDispatcher will be constructed with full dependencies (CAS, ledger, clock, broker) via a new with_full_context method, preserving with_persistence for tests"
      context: |
        The current with_persistence method constructs SessionDispatcher without CAS, ledger, clock, or broker.
        We need to enable real tool execution and event persistence without breaking existing tests.
      alternatives:
        - id: "ALT-0001"
          name: "Modify with_persistence to require all dependencies"
          pros:
            - "Single construction path"
          cons:
            - "Breaks all existing tests"
            - "Forces test complexity for simple dispatch tests"
          security_tradeoffs: []
          operability_tradeoffs:
            - "Higher test maintenance burden"
        - id: "ALT-0002"
          name: "Add with_full_context method alongside with_persistence"
          pros:
            - "Backward compatible"
            - "Tests can use minimal construction"
            - "Production uses full construction"
          cons:
            - "Two construction paths to maintain"
          security_tradeoffs:
            - "Must ensure with_persistence cannot be used in production paths"
          operability_tradeoffs: []
      chosen_rationale: "ALT-0002 chosen: backward compatibility and test ergonomics outweigh maintenance cost; production path enforcement via compile-time feature flag or module visibility"
      impacted_requirement_ids:
        - "REQ-0001"
      evidence_ids:
        - "EVID-GROUND-001"
      codebase_grounding: |
        SessionDispatcher builder pattern verified at session_dispatch.rs:419-541.
        with_full_context extends existing with_ledger, with_cas, with_broker, with_clock methods.

    - id: "DEC-0002"
      title: "Tool log artifact format"
      statement: "Use hash-first audit for v4: store ToolResultData per call and a ToolLogIndexV1 that indexes tool result hashes; ToolExecutionReceipt is an optional proof-carrying addendum"
      context: |
        Tool execution stores results to CAS but doesn't surface hashes for receipts.
        We need a scalable, replayable audit surface that stays stable as evidence volume grows.

        v4 minimum (aligned with Q-0001 resolution):
        - ToolLogIndexV1 indexes ToolResultData hashes only (result hashes already bind relevant metadata).

        Optional addendum (future hardening):
        - ToolExecutionReceipt provides a signed proof-carrying actuation record binding args/result/policy/envelope,
          and future ToolLogIndex variants MAY index ToolExecutionReceipt hashes instead of (or in addition to)
          ToolResultData hashes.
      alternatives:
        - id: "ALT-0001"
          name: "Option A: Store only ToolResultData hashes (no index)"
          pros:
            - "Simple implementation"
            - "Direct CAS lookups"
          cons:
            - "No single artifact lists all tool invocations by canonical order"
            - "Harder to audit full session"
          security_tradeoffs: []
          operability_tradeoffs:
            - "Auditing requires traversing receipt to find all hashes"
        - id: "ALT-0002"
          name: "Option B: ToolResultData hashes + ToolLogIndexV1 (v4 minimum)"
          pros:
            - "Single-pointer audit (tool_log_index_hash)"
            - "Preserves per-call ToolResultData retrieval by hash"
            - "Index includes bounded metadata and is chunkable/Merkle-friendly"
          cons:
            - "Additional artifact to store (index)"
          security_tradeoffs: []
          operability_tradeoffs:
            - "Better audit ergonomics + replayability"
      chosen_rationale: "ALT-0002 chosen: ToolLogIndexV1 provides scalable audit ergonomics while keeping v4 minimum simple; ToolExecutionReceipt remains an optional hardening addendum"
      impacted_requirement_ids:
        - "REQ-0004"
        - "REQ-0010"
      evidence_ids:
        - "EVID-GROUND-002"
      codebase_grounding: |
        Executor stores ToolResultData to CAS but result_hash is not surfaced through tool
        responses/receipts (crates/apm2-daemon/src/episode/executor.rs). The repo has receipt
        infrastructure (crates/apm2-daemon/src/evidence/receipt.rs) but FAC does not yet emit
        proof-carrying ToolExecutionReceipts, and ToolLogIndexV1 is net-new.

    - id: "DEC-0003"
      title: "Workspace isolation strategy"
      statement: "Create ephemeral workspace directories per-episode in a daemon-managed temp root, with automatic cleanup on episode completion/abort"
      context: |
        Workspace apply is stubbed. Need to implement isolated filesystems for reviewer episodes
        that prevent escape and enable consistent tool behavior.
      alternatives:
        - id: "ALT-0001"
          name: "Per-session workspace in /tmp"
          pros:
            - "Simple implementation"
            - "OS-managed cleanup on reboot"
          cons:
            - "No control over cleanup timing"
            - "Shared /tmp could leak information"
          security_tradeoffs:
            - "Other processes can see workspace paths"
          operability_tradeoffs:
            - "Disk space management depends on OS"
        - id: "ALT-0002"
          name: "Daemon-managed workspace root with lifecycle management"
          pros:
            - "Explicit cleanup on episode completion"
            - "Controlled disk usage"
            - "Can implement retention policies"
          cons:
            - "More implementation complexity"
          security_tradeoffs:
            - "Daemon controls cleanup timing"
          operability_tradeoffs:
            - "Better observability of workspace state"
      chosen_rationale: "ALT-0002 chosen: daemon control over workspace lifecycle enables explicit cleanup and disk management"
      impacted_requirement_ids:
        - "REQ-0003"
      evidence_ids:
        - "EVID-GROUND-003"
      codebase_grounding: |
        WorkspaceManager::apply() stubbed at workspace.rs:740-755. Validation exists
        via validate_path() at lines 337-381 (6 layers). RFC completes stub implementation.

    - id: "DEC-0004"
      title: "Projection idempotency mechanism"
      statement: "Use durable projection receipts keyed by (work_id, review_receipt_hash) to prevent duplicate projections"
      context: |
        Projection worker needs to be idempotent across restarts.
        Must not duplicate GitHub comments or statuses.
      alternatives:
        - id: "ALT-0001"
          name: "GitHub API deduplication (check before post)"
          pros:
            - "No local state needed"
          cons:
            - "Race conditions possible"
            - "Depends on GitHub state (violates truth-is-internal)"
          security_tradeoffs:
            - "GitHub state could be tampered"
          operability_tradeoffs:
            - "Additional API calls per projection"
        - id: "ALT-0002"
          name: "Durable projection receipts in CAS+ledger"
          pros:
            - "Truth is internal"
            - "Audit trail for all projections"
            - "No race conditions (ledger ordering)"
          cons:
            - "Additional storage"
          security_tradeoffs:
            - "Maintains internal truth invariant"
          operability_tradeoffs:
            - "Clear audit trail"
      chosen_rationale: "ALT-0002 chosen: maintains truth-is-internal constraint and provides audit trail"
      impacted_requirement_ids:
        - "REQ-0006"
      evidence_ids:
        - "EVID-GROUND-004"
      codebase_grounding: |
        IdempotencyCache is SQLite-backed at github_sync.rs:484-618 with unique constraint.
        ProjectionReceipt exists at projection_receipt.rs:214-238. RFC integrates with ledger.

    - id: "DEC-0005"
      title: "Capability manifest storage and loading"
      statement: "Store capability manifests as CAS artifacts (JSON-serialized) and load by hash during SpawnEpisode, with hash verification on load"
      context: |
        REQ-0002 requires real capability manifests, not empty allowlist stubs.
        Need to decide storage format and integrity verification approach.
      alternatives:
        - id: "ALT-0001"
          name: "In-memory manifest registry"
          pros:
            - "Fast lookup"
            - "Simple implementation"
          cons:
            - "Lost on restart"
            - "Not durable or auditable"
          security_tradeoffs:
            - "No integrity verification"
          operability_tradeoffs:
            - "Cannot reproduce manifest state"
        - id: "ALT-0002"
          name: "CAS-backed manifest storage with hash verification"
          pros:
            - "Durable and immutable"
            - "Content addressing ensures integrity"
            - "Manifest versions are auditable"
          cons:
            - "CAS dependency for spawn"
          security_tradeoffs:
            - "Content hash prevents tampering"
          operability_tradeoffs:
            - "Manifest history preserved"
      chosen_rationale: "ALT-0002 chosen: CAS provides integrity, durability, and auditability; aligns with truth-is-internal principle"
      impacted_requirement_ids:
        - "REQ-0002"
      evidence_ids:
        - "EVID-GROUND-005"
      codebase_grounding: |
        ManifestStore and is_tool_allowed() exist at capability.rs:1173-1179 with fail-closed
        semantics (TCK-00254). Legacy allow path uses manifest at session_dispatch.rs:967-1006.

    - id: "DEC-0006"
      title: "Episode event persistence mechanism"
      statement: "Stream episode events directly to ledger via LedgerEventEmitter, replacing in-memory buffer"
      context: |
        REQ-0005 requires episode events to persist to ledger and survive daemon restart.
        Current in-memory buffer loses events on crash.
      alternatives:
        - id: "ALT-0001"
          name: "Keep in-memory buffer with periodic flush"
          pros:
            - "Lower write frequency"
            - "Batching efficiency"
          cons:
            - "Events lost on crash"
            - "Ordering guarantees complex"
          security_tradeoffs:
            - "Crash window loses audit trail"
          operability_tradeoffs:
            - "Delayed event visibility"
        - id: "ALT-0002"
          name: "Direct ledger streaming"
          pros:
            - "Events durable immediately"
            - "Survives daemon restart"
            - "Simple ordering (ledger sequence)"
          cons:
            - "Higher write frequency"
            - "Ledger dependency for each event"
          security_tradeoffs:
            - "Full audit trail preserved"
          operability_tradeoffs:
            - "Real-time event visibility"
      chosen_rationale: "ALT-0002 chosen: durability and audit trail outweigh write frequency cost; ledger is designed for event append workload"
      impacted_requirement_ids:
        - "REQ-0005"
      evidence_ids:
        - "EVID-GROUND-006"
      codebase_grounding: |
        LedgerEventEmitter trait at dispatch.rs:177-223 with SqliteLedgerEventEmitter at
        ledger.rs:32-70. RFC uses existing infrastructure for episode event streaming.

    - id: "DEC-0007"
      title: "xtask authority reduction approach"
      statement: "Stage xtask demotion via explicit CLI flags, defaulting to projection worker for GitHub writes"
      context: |
        REQ-0007 requires reducing xtask authority progressively.
        Need to balance backward compatibility with security improvement.
      alternatives:
        - id: "ALT-0001"
          name: "Hard cutover - remove xtask GitHub writes immediately"
          pros:
            - "Clean break"
            - "Forces projection worker adoption"
          cons:
            - "Breaking change for existing workflows"
            - "No fallback if projection worker fails"
          security_tradeoffs:
            - "Immediate authority reduction"
          operability_tradeoffs:
            - "Operational risk during transition"
        - id: "ALT-0002"
          name: "Staged cutover with explicit flags"
          pros:
            - "Backward compatible"
            - "Gradual migration"
            - "Fallback available during transition"
          cons:
            - "Longer transition period"
            - "Two write paths temporarily"
          security_tradeoffs:
            - "Legacy path requires explicit flag"
          operability_tradeoffs:
            - "Controlled rollout"
      chosen_rationale: "ALT-0002 chosen: staged rollout reduces operational risk; explicit flags maintain audit trail; legacy path deprecated not removed"
      impacted_requirement_ids:
        - "REQ-0007"
      evidence_ids:
        - "EVID-GROUND-007"
      codebase_grounding: |
        Policy decision using CLI flags. No existing code duplication concern.
        Staged rollout is an operational change, not architectural.

    - id: "DEC-0008"
      title: "Adapter bridging default for heterogeneous CLIs"
      statement: "Default to a black-box, kernel-tool-mediated adapter (Option C); allow structured-output (Option B) and MCP bridge (Option A) only when they reduce net risk"
      context: |
        FAC v0 needs a deterministic contract to run third-party agent CLIs (claude-code, gemini-cli, codex-cli)
        and local inference. The kernel must remain authoritative for tool execution and evidence capture.

        The draft RFC enumerates three bridging approaches with different reliability and configuration risks.
      alternatives:
        - id: "ALT-0001"
          name: "Option A: MCP bridge"
          pros:
            - "Explicit tool schemas; structured transport"
            - "Kernel-side tool execution remains possible"
          cons:
            - "High configuration complexity across agents"
            - "Client behavior drift; schema sanitization drift"
          security_tradeoffs:
            - "Must prevent schema expansion and tool discovery drift"
          operability_tradeoffs:
            - "Operational burden: per-agent config + version skew management"
        - id: "ALT-0002"
          name: "Option B: Structured output parsing (json/jsonl/stream-json)"
          pros:
            - "Lower config burden than MCP for many CLIs"
            - "Structured parsing can be fail-closed"
          cons:
            - "Output-format drift; brittle parsing under vendor updates"
          security_tradeoffs:
            - "Must rate-limit and fail closed on parse errors"
          operability_tradeoffs:
            - "Requires conformance tests per agent version range"
        - id: "ALT-0003"
          name: "Option C: Black-box ledger-mediated driver (preferred)"
          pros:
            - "Works across heterogeneous CLIs with minimal vendor coupling"
            - "Preserves holonic boundary discipline: kernel is sole authority for tool execution"
            - "Simpler operational deployment"
          cons:
            - "Lower UX richness vs. vendor-native structured tool calling"
          security_tradeoffs:
            - "Requires strict ToolIntent grammar + validation to avoid prompt-based ambiguity"
          operability_tradeoffs:
            - "Most robust default across agents; minimal per-agent config surface"
      chosen_rationale: "ALT-0003 chosen: minimizes integration fragility while preserving kernel-side tool authority; ALT-0001/ALT-0002 allowed only when they reduce net risk for a target agent"
      impacted_requirement_ids:
        - "REQ-0009"
      evidence_ids: []
