rfc_design_decisions:
  schema_version: "2026-01-24"
  template_version: "2026-01-24"
  decisions:
  - id: DD-001
    title: "Use serde JSON Deserialization for CI Status Parsing"
    statement: |
      Replace string matching with proper serde_json deserialization when parsing
      the output of `gh pr checks --json`. Define a CheckRun struct with name,
      state, and conclusion fields. Use #[serde(default)] to handle missing fields.
    context: |
      The current implementation uses string contains checks like
      `output.contains("\"conclusion\":\"FAILURE\"")` which is fragile and fails
      when the JSON structure includes warnings or differs from expectations.
      The error "Unknown JSON field: conclusion" suggests the gh CLI is outputting
      a warning that gets mixed with the JSON output.
    alternatives:
    - id: ALT-0001
      name: "Keep string matching but handle warnings"
      pros:
      - "Minimal code change"
      cons:
      - "Still fragile to JSON structure changes"
      - "Difficult to handle all edge cases"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Debugging failures requires understanding string matching logic"
    - id: ALT-0002
      name: "Use serde JSON deserialization (chosen)"
      pros:
      - "Type-safe parsing with clear error messages"
      - "Handles unknown fields gracefully with #[serde(default)]"
      - "Standard Rust idiom; easy to maintain"
      - "Compiler catches field name typos"
      cons:
      - "Requires defining CheckRun struct"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Better error messages when parsing fails"
    chosen_rationale: |
      Serde deserialization is the standard Rust approach for JSON parsing.
      It provides type safety, clear error messages, and gracefully handles
      optional or unknown fields. The serde_json dependency is already in xtask.
    impacted_requirement_ids:
    - MAINT-001
    evidence_ids:
    - EVID-5001

  - id: DD-002
    title: "Fix gh api Argument Passing for Status Creation"
    statement: |
      Fix the argument passing to gh api by using separate variables for each
      field value, ensuring xshell correctly quotes multi-word strings. Also
      check the actual command status (not just .is_ok()) before claiming success.
    context: |
      The cmd! macro in xshell splits arguments on whitespace. The current code:
      `gh api --method POST {endpoint} -f state=pending -f description=Waiting for security review`
      causes "Waiting for security review" to be split into 4 arguments.
      Additionally, .is_ok() on .run() only indicates the command was executed,
      not that gh api returned success.
    alternatives:
    - id: ALT-0001
      name: "Use shell quoting in the command string"
      pros:
      - "Single line change"
      cons:
      - "Shell quoting is error-prone"
      - "Doesn't fix the success detection issue"
      security_tradeoffs:
      - "Incorrect quoting could lead to injection"
      operability_tradeoffs: []
    - id: ALT-0002
      name: "Use variables for field values (chosen)"
      pros:
      - "xshell handles quoting correctly for variables"
      - "Clear, readable code"
      - "Can check command output for errors"
      cons:
      - "More verbose"
      security_tradeoffs:
      - "xshell escaping prevents injection"
      operability_tradeoffs:
      - "Error messages propagated to user"
    chosen_rationale: |
      Using separate variables for multi-word strings is the correct xshell pattern.
      The macro properly escapes variable content. Combined with checking command
      output, this ensures status creation is reliable and failures are visible.
    impacted_requirement_ids:
    - MAINT-002
    evidence_ids:
    - EVID-5002

  - id: DD-003
    title: "Update Codex CLI Invocation to Use Correct Syntax"
    statement: |
      Replace the incorrect `codex -m o3 --approval-mode full-auto <prompt>` with
      `codex review --base main`. The review subcommand is the correct entry point
      for code review, and --base specifies the comparison branch.
    context: |
      The current code uses CLI flags that don't exist in Codex (--approval-mode).
      The Codex CLI API uses subcommands; `codex review` is the code review
      subcommand that compares against a base branch.
    alternatives:
    - id: ALT-0001
      name: "Research current Codex API and adapt"
      pros:
      - "Future-proof if API changes"
      cons:
      - "Requires API documentation"
      security_tradeoffs: []
      operability_tradeoffs: []
    - id: ALT-0002
      name: "Use codex review --base main (chosen)"
      pros:
      - "Matches documented Codex CLI usage"
      - "Simple fix"
      cons:
      - "May need updates if Codex API changes"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Review automatically uses main as comparison base"
    chosen_rationale: |
      The `codex review --base main` syntax is the documented way to run code
      reviews with Codex. This matches the pattern used in push.rs where Codex
      should also be updated to use consistent invocation.
    impacted_requirement_ids:
    - MAINT-003
    evidence_ids:
    - EVID-5003

  - id: DD-004
    title: "Add Local Pre-Commit Checks to commit Command"
    statement: |
      Enhance `cargo xtask commit` to run local validation checks before creating
      the commit: cargo fmt --check, cargo clippy, and cargo semver-checks
      (if available). This catches common issues before push, reducing CI failures.
    context: |
      Currently, issues like formatting violations and semver breakage are only
      caught in CI after push. Running these checks locally in the commit command
      provides faster feedback and prevents wasted CI cycles. The semver check
      is particularly important as it's a common source of CI failures.
    alternatives:
    - id: ALT-0001
      name: "Keep commit simple, let CI catch issues"
      pros:
      - "Faster local commit"
      - "No local tooling requirements"
      cons:
      - "Delays feedback until CI"
      - "Wastes CI resources on obvious failures"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Developer waits for CI to find issues"
    - id: ALT-0002
      name: "Add pre-commit checks to commit command (chosen)"
      pros:
      - "Immediate feedback on common issues"
      - "Reduces CI failures"
      - "Consistent with fail-fast principle"
      cons:
      - "Slower commit if checks fail"
      - "Requires local tools (clippy, semver-checks)"
      security_tradeoffs: []
      operability_tradeoffs:
      - "May need --skip-checks flag for emergency commits"
    chosen_rationale: |
      Running local checks before commit follows the fail-fast principle. Issues
      caught locally are fixed faster than those caught in CI. The commit command
      should include a --skip-checks flag for cases where quick iteration is needed.
    impacted_requirement_ids:
    - MAINT-004
    evidence_ids:
    - EVID-5004
