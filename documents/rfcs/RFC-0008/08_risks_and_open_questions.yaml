rfc_risks_and_open_questions:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"

  risks:
    - id: RISK-008-001
      description: "Webhook secret compromise"
      likelihood: LOW
      impact: HIGH
      mitigation: |
        If the webhook secret is compromised, attackers could fake CI completion
        events, bypassing CI quality gates.

        Mitigations:
        - Store secret in secure secrets manager (not env vars in code)
        - Implement secret rotation mechanism
        - Monitor for unusual webhook patterns (anomaly detection)
        - Log all webhook source IPs
        - Implement replay attack detection via delivery_id + timestamp

    - id: RISK-008-002
      description: "Webhook endpoint unavailability"
      likelihood: MEDIUM
      impact: MEDIUM
      mitigation: |
        If the webhook endpoint is down, CI completion events are missed and
        work items remain in CI_PENDING indefinitely.

        Mitigations:
        - GitHub retries webhook delivery (configurable)
        - Implement dead letter queue for failed deliveries
        - Add monitoring and alerting for endpoint health
        - Provide manual recovery mechanism to transition stuck work

    - id: RISK-008-003
      description: "GitHub webhook format changes"
      likelihood: LOW
      impact: MEDIUM
      mitigation: |
        GitHub may change the webhook payload format in future versions.

        Mitigations:
        - Parse only fields we need (defensive parsing)
        - Log unknown fields for monitoring
        - Subscribe to GitHub changelog
        - Integration tests catch breaking changes

    - id: RISK-008-004
      description: "Agent gaming via other vectors"
      likelihood: MEDIUM
      impact: MEDIUM
      mitigation: |
        While we prevent agents from setting CI status via our API, they might
        try other vectors:
        - Directly calling GitHub API to update checks
        - Modifying workflow files to skip checks
        - Creating PRs that bypass required checks

        Mitigations:
        - Use GitHub branch protection rules (required checks)
        - Restrict agent GitHub token permissions (no checks:write)
        - Audit trail of all status changes with source
        - Monitor for suspicious patterns

    - id: RISK-008-005
      description: "Queue semantics edge cases"
      likelihood: MEDIUM
      impact: LOW
      mitigation: |
        Edge cases in task queue state machine:
        - CI runs multiple times (reruns, pushes)
        - CI completes for wrong commit
        - Multiple PRs for same work item

        Mitigations:
        - Match CI events to work items via commit SHA
        - Handle CI reruns (re-emit events, idempotent transitions)
        - One PR per work item (enforced by protocol)

    - id: RISK-008-006
      description: "Latency between CI completion and agent handoff"
      likelihood: LOW
      impact: LOW
      mitigation: |
        There will be some latency between CI completing and a new agent
        claiming the work. This is acceptable for our use case.

        Mitigations:
        - Monitor handoff latency metric
        - Optimize event processing pipeline if needed
        - Latency is still far better than polling

    - id: RISK-008-007
      description: "Agent exit signal not emitted"
      likelihood: MEDIUM
      impact: MEDIUM
      mitigation: |
        Agents may crash or be terminated before emitting exit signal.

        Mitigations:
        - Detect orphaned work items (agent lease expired, no exit signal)
        - Auto-transition based on PR creation (if PR exists, assume impl done)
        - Allow manual transition by operator
        - Timeout mechanism for work items in IMPLEMENTATION phase

  open_questions:
    - id: OQ-008-001
      question: "Should we support webhook delivery verification?"
      status: DEFERRED
      notes: |
        GitHub provides a webhook deliveries API to check delivery status.
        We could periodically verify recent deliveries were processed.
        Defer until we see evidence of missed webhooks.

    - id: OQ-008-002
      question: "How to handle CI reruns?"
      status: RESOLVED
      resolution: |
        CI reruns emit new workflow_run.completed events. We handle them as
        follows:
        - If work is still in CI_PENDING, update based on new result
        - If work already transitioned, log but don't change state
        - Idempotency via delivery_id prevents double-processing same event

    - id: OQ-008-003
      question: "Should agents be allowed to request CI rerun?"
      status: DEFERRED
      notes: |
        Currently agents cannot trigger CI reruns. They would need to push
        an empty commit or use GitHub API. Defer this capability until
        there's a clear use case.

    - id: OQ-008-004
      question: "How to handle partial CI (some checks pass, some fail)?"
      status: RESOLVED
      resolution: |
        The workflow_run.completed event represents the overall workflow
        conclusion, not individual checks. We use:
        - conclusion: "success" -> all required checks passed
        - conclusion: "failure" -> at least one required check failed
        - Individual check results stored in event for debugging

    - id: OQ-008-005
      question: "Should we support multiple concurrent CI workflows?"
      status: RESOLVED
      resolution: |
        Multiple workflows can run concurrently (e.g., different workflow
        files). We process all workflow_run.completed events. The work item
        transitions when ALL required workflows succeed, or BLOCKS if any
        required workflow fails. Required workflows are configured per-repo.

  decisions_needed:
    - id: DN-008-001
      question: "Where to deploy webhook endpoint?"
      options:
        - "Same server as apm2 daemon"
        - "Separate webhook service"
        - "Serverless function (Lambda/Cloud Functions)"
      chosen: "TBD"
      rationale: |
        Deployment depends on infrastructure available. Serverless is simplest
        for webhook handling but may have cold start latency. Same server is
        simplest if daemon is always running. Decision deferred to implementation.

    - id: DN-008-002
      question: "Secret storage mechanism?"
      options:
        - "Environment variable"
        - "File on disk (0600 permissions)"
        - "Secrets manager (AWS Secrets Manager, HashiCorp Vault)"
      chosen: "Environment variable (initial), secrets manager (production)"
      rationale: |
        Environment variables are simplest for development and small deployments.
        Production deployments should use a secrets manager for rotation and
        audit capabilities.

    - id: DN-008-003
      question: "How long to retain delivery_id for idempotency?"
      options:
        - "1 hour"
        - "24 hours"
        - "7 days"
      chosen: "24 hours"
      rationale: |
        GitHub retries webhooks for up to 1 hour by default. 24 hours provides
        margin for manual redelivery. Beyond that, duplicate events would
        likely be from replay attacks anyway.
