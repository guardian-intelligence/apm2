APM2’s secrets management policy is designed to satisfy a set of industry-aligned controls for credential confidentiality, least-privilege usage, auditability, and supply-chain isolation, with explicit attention to common compliance frameworks such as OWASP Top 10 (A02:2021 Cryptographic Failures and related credential-handling risks), CIS Controls (notably Control 3 and sub-controls concerning secure handling of sensitive data), and SLSA L3 expectations for build integrity and secret isolation. The policy assumes that secret exposure is both high-impact and operationally likely unless prevented by mechanical controls; therefore, it formalizes where secrets may exist (memory, keyring, CI secret store), how secrets are transmitted to workloads, how they are prevented from entering logs and artifacts, and how leaks are handled when prevention fails.

From an OWASP perspective, the dominant risk class addressed here is A02:2021 Cryptographic Failures, interpreted broadly as “confidentiality failures” that include inadvertent secret disclosure in source control, logs, artifacts, or insecure storage. APM2 applies a layered prevention model: (1) prohibit secrets in the repository, (2) store long-lived secrets in platform-provided secure stores, (3) inject secrets into processes only at runtime and only when necessary, (4) enforce redaction on all outbound text channels, and (5) scan persistence and release surfaces for secret material. This aligns with modern secure SDLC doctrine: treat secret leakage as a supply-chain vulnerability, not merely an application bug.

CIS Controls emphasize the systematic management of sensitive data at rest and in transit, including encryption, access control, and monitoring. APM2 operationalizes this by dividing secrets into distinct classes with distinct custody boundaries: runtime user credentials, CI/CD secrets, and signing keys (explicitly absent due to keyless signing). The segregation is a core control: user credentials are never stored in plaintext files; CI/CD credentials are never stored on developer machines; and release-signing identity is not implemented as a private key material problem at all (keyless signing), reducing the long-lived secret burden. This partitioning reduces blast radius and supports targeted incident response, because compromise of one domain does not imply compromise of the others.

In the runtime domain, APM2 treats user credentials as high-value secrets whose lifecycle must be explicitly managed. API keys (e.g., Anthropic/Claude and OpenAI keys), session tokens, and OAuth tokens are managed through an apm2-core credentials module and stored in the host’s OS keyring (macOS Keychain, Windows Credential Manager, or Linux Secret Service). The policy’s intent is to leverage platform-backed encryption and access mediation rather than re-implementing cryptographic storage in application code. This design is consistent with CIS guidance: use established secret stores with well-understood access controls and avoid ad hoc plaintext credential storage.

In-memory handling is implemented with explicit “secret” types (SecretString) and explicit exposure semantics. The policy mandates the use of secrecy::SecretString instead of String for sensitive material to reduce accidental disclosure through debugging, cloning, or logging. This aligns with secure coding best practices: secrets are stored in memory using types that (a) avoid accidental display via Debug formatting, (b) provide explicit access only at the point of use via ExposeSecret, and (c) support best-effort memory scrubbing (zeroization) on drop. While memory zeroization is not a complete defense against process compromise, it is an industry-standard mitigation to reduce residual secret lifetime and accidental propagation.

The runtime secret distribution model relies on on-demand retrieval and environment-variable injection into managed processes, mediated by the APM2 process manager (apm2-daemon). This is a pragmatic control that maps to least-privilege and scoping: the daemon retrieves secrets from the keyring only when needed, injects them into a specific managed process instance, and then relies on process boundaries to limit propagation. In practical SDLC terms, this constrains the secret’s exposure surface: it is not baked into binaries, not stored in project configuration, and not generally available to unrelated processes. The policy additionally prescribes careful command construction such that secrets are not passed via command-line arguments (which are commonly observable via process listings) and are instead passed via environment, which has a smaller and more controllable exposure surface.

Log and artifact hygiene is treated as a hard invariant, reflecting the reality that logs and build artifacts are frequent and durable exfiltration channels. APM2 therefore mandates that all log output passes through a redaction filter (SecretRedactor), and that environment variable names matching sensitive patterns (*_KEY, *_TOKEN, *_SECRET, *_PASSWORD, cloud/provider prefixes) trigger automatic redaction. This is an operational enforcement of OWASP’s guidance to avoid sensitive data in logs and aligns with the CIS emphasis on controlling data exposure. The policy extends beyond runtime logs to include API response bodies, error messages, and any other textual channels where credentials may accidentally appear.

To further reduce leakage risk, APM2 requires scanning before persistence. This means file writes, build outputs, and release artifacts are treated as potential leakage paths and must be scanned for secret material before they are persisted or published. This approach reflects an industry “defense in depth” posture: even if developers follow best practices, accidental inclusion can occur through generated files, debug dumps, or vendor tooling. The policy’s release integrity requirements (SBOM production and artifact publishing) implicitly increase the visibility and distribution of release assets; therefore, scanning before publication is a necessary complement to signing and provenance, not an optional improvement.

The CI/CD secret model is designed to satisfy the separation goals typical of SLSA-aligned pipelines. CI secrets (e.g., CARGO_REGISTRY_TOKEN, CODECOV_TOKEN) are stored in GitHub Actions Secrets and injected into workflows only at execution time. This is consistent with SLSA L3 expectations that secrets are not embedded in source and are isolated to controlled build environments. In practice, APM2’s policy implies that the build pipeline must avoid printing secrets, must use “silent” flags where tools might echo tokens, and must treat any step that can expose secrets as security-critical. Rotation requirements are defined with explicit time horizons (e.g., 90-day token rotation for publish credentials) and compromise-driven triggers, which is consistent with standard enterprise token hygiene.

A distinctive feature of the policy is the explicit elimination of release-signing private keys from the secrets inventory through Sigstore keyless signing. From a control perspective, this is a major simplification: it removes the need to store, rotate, and protect a long-lived signing key, and instead relies on workload identity (OIDC), short-lived certificates, and transparency logs. This materially reduces the risk profile associated with signing keys—traditionally one of the most sensitive assets in a software supply chain—while preserving verifiability and auditability.

The policy also defines a clear incident response posture for secret leakage, consistent with industry practice: revoke immediately, rotate, audit for misuse, remediate repository history if applicable, and document the event. The ordering is important: revocation and rotation are prioritized over forensics to minimize attacker dwell time. This maps to standard incident response doctrine and supports compliance expectations that sensitive incidents are handled promptly and consistently. By treating secret leaks as security incidents regardless of whether exploitation is proven, the policy avoids the common failure mode of delaying action until after damage occurs.

Finally, the policy provides explicit guidance for testing workflows to prevent “test convenience” from becoming a leak vector. In CI, secrets must be provided via GitHub Actions secrets and only to the jobs that require them, supporting least privilege. Locally, .env files are permitted only if they are gitignored, never committed, and loaded via controlled mechanisms. This aligns with OWASP guidance around configuration and secret separation and reflects CIS expectations that developers not create shadow secret stores. The compliance mapping is therefore not merely rhetorical: the approach is structurally designed to minimize the common channels by which secret material enters repositories, logs, artifacts, and uncontrolled developer environments.

In summary, APM2’s secrets management approach is a multi-layer control system: platform-backed secret storage for runtime credentials, CI secret isolation and rotation for pipeline tokens, elimination of signing keys via keyless signing, pervasive redaction for all text surfaces, scanning for persistence surfaces, and prescriptive incident response. The policy prioritizes measurable, automatable controls aligned with OWASP, CIS, and SLSA-aligned supply chain practices, with an explicit bias toward preventing both accidental disclosure and systemic leakage through durable artifacts and telemetry.