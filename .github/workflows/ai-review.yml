# Unified AI Review projection workflow
# Runs in PR-branch context (push semantics) so prompt/evaluator changes in the
# PR apply immediately.
# Primary execution substrate is FAC on VPS; GitHub is a thin projection layer.

name: AI Review

on:
  push:
    branches-ignore: [main]
  workflow_dispatch: {}

concurrency:
  group: ai-review-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  RUSTFLAGS: -D warnings
  RUST_BACKTRACE: 1

jobs:
  fac-review:
    name: FAC Review
    runs-on: [self-hosted, linux, x64, fac-ovh]
    timeout-minutes: 45

    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561 # stable
        with:
          toolchain: stable

      - uses: Swatinem/rust-cache@ad397744b0d591a723ab90405b7247fac0e6b8db # v2

      - name: Add Cargo bin to PATH
        run: |
          if [[ -n "${CARGO_HOME:-}" ]]; then
            echo "${CARGO_HOME}/bin" >> "$GITHUB_PATH"
          else
            echo "${HOME}/.cargo/bin" >> "$GITHUB_PATH"
          fi

      - name: Resolve PR context from branch
        id: pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          OWNER_REPO="${{ github.repository }}"
          OWNER="${OWNER_REPO%%/*}"
          BRANCH="${{ github.ref_name }}"

          PR_DATA=$(gh api "/repos/${OWNER_REPO}/pulls?head=${OWNER}:${BRANCH}&state=open&per_page=10")
          PR_NUMBER=$(echo "$PR_DATA" | jq -r '.[0].number // empty')
          if [[ -z "$PR_NUMBER" ]]; then
            echo "No open PR found for ${OWNER}:${BRANCH}; skipping."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          HEAD_SHA=$(echo "$PR_DATA" | jq -r '.[0].head.sha')
          BASE_REF=$(echo "$PR_DATA" | jq -r '.[0].base.ref')
          HEAD_REPO=$(echo "$PR_DATA" | jq -r '.[0].head.repo.full_name')

          if [[ "$HEAD_REPO" != "$OWNER_REPO" ]]; then
            echo "Refusing to run on non-local head repo: ${HEAD_REPO}"
            exit 1
          fi

          if [[ -z "$BASE_REF" ]]; then
            echo "::error::Could not resolve PR base ref; refusing to evaluate with mutable PR-branch policy."
            exit 1
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "head_sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"
          echo "base_ref=${BASE_REF}" >> "$GITHUB_OUTPUT"
          echo "pr_url=https://github.com/${OWNER_REPO}/pull/${PR_NUMBER}" >> "$GITHUB_OUTPUT"

      - name: Fetch trusted reviewers from base branch
        if: steps.pr.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          git fetch origin "${{ steps.pr.outputs.base_ref }}" --depth=1
          git show "origin/${{ steps.pr.outputs.base_ref }}:.github/review-gate/trusted-reviewers.json" \
            > /tmp/trusted-reviewers-base.json

      - name: Validate review bot identity is allowlisted
        if: steps.pr.outputs.skip != 'true'
        env:
          REVIEW_BOT_TOKEN: ${{ secrets.AUTO_APPROVE_PAT }}
        run: |
          set -euo pipefail

          if [[ -z "${REVIEW_BOT_TOKEN:-}" ]]; then
            echo "::error::Missing required secret AUTO_APPROVE_PAT (must map to an allowlisted reviewer identity)."
            exit 1
          fi

          BOT_LOGIN=$(GH_TOKEN="${REVIEW_BOT_TOKEN}" gh api user --jq '.login')
          echo "Using review bot login: ${BOT_LOGIN}"

          jq -e --arg login "$BOT_LOGIN" \
            '[.reviewers.security[].github_logins[] | ascii_downcase] | index($login|ascii_downcase) != null' \
            /tmp/trusted-reviewers-base.json >/dev/null

          jq -e --arg login "$BOT_LOGIN" \
            '[.reviewers.code_quality[].github_logins[] | ascii_downcase] | index($login|ascii_downcase) != null' \
            /tmp/trusted-reviewers-base.json >/dev/null

      - name: Delete prior review artifacts for this head (dedupe)
        if: steps.pr.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.AUTO_APPROVE_PAT }}
        run: |
          set -euo pipefail

          if [[ -z "${GH_TOKEN:-}" ]]; then
            echo "::error::Missing required secret AUTO_APPROVE_PAT (authoritative reviewer identity token)."
            exit 1
          fi

          OWNER_REPO="${{ github.repository }}"
          PR_NUMBER="${{ steps.pr.outputs.pr_number }}"
          HEAD_SHA="${{ steps.pr.outputs.head_sha }}"
          BOT_LOGIN=$(gh api user --jq '.login')

          MARKERS=(
            "<!-- apm2-review-metadata:v1:security -->"
            "<!-- apm2-review-metadata:v1:code-quality -->"
          )

          for marker in "${MARKERS[@]}"; do
            IDS=$(gh api "/repos/${OWNER_REPO}/issues/${PR_NUMBER}/comments?per_page=100" --paginate --jq \
              "[.[] | select(.user.login == \"${BOT_LOGIN}\") | select((.body // \"\") | contains(\"${marker}\")) | select((.body // \"\") | contains(\"${HEAD_SHA}\")) | .id] | .[]")

            if [[ -z "${IDS:-}" ]]; then
              continue
            fi

            while IFS= read -r id; do
              if [[ -n "${id}" ]]; then
                gh api --method DELETE "/repos/${OWNER_REPO}/issues/comments/${id}"
              fi
            done <<< "$IDS"
          done

      - name: Run FAC reviews in parallel with 1Hz status projection
        if: steps.pr.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.AUTO_APPROVE_PAT }}
        run: |
          set -euo pipefail

          if [[ -z "${GH_TOKEN:-}" ]]; then
            echo "::error::Missing required secret AUTO_APPROVE_PAT (authoritative reviewer identity token)."
            exit 1
          fi

          if ! command -v jq >/dev/null 2>&1; then
            echo "::error::jq is required for FAC review status projection."
            exit 1
          fi

          PR_URL="${{ steps.pr.outputs.pr_url }}"
          PR_NUMBER="${{ steps.pr.outputs.pr_number }}"
          HEAD_SHA="${{ steps.pr.outputs.head_sha }}"

          if command -v apm2 >/dev/null 2>&1; then
            FAC_BIN=(apm2)
          else
            cargo build --locked -p apm2-cli
            FAC_BIN=(target/debug/apm2)
          fi

          RUN_DIR=$(mktemp -d /tmp/apm2-ai-review-XXXXXX)
          SEC_LOG="${RUN_DIR}/security.log"
          QUAL_LOG="${RUN_DIR}/quality.log"

          terminate_children() {
            set +e
            for pid in ${SEC_PID:-} ${QUAL_PID:-}; do
              if [[ -n "${pid:-}" ]] && kill -0 "${pid}" 2>/dev/null; then
                kill "${pid}" 2>/dev/null || true
              fi
            done
            wait ${SEC_PID:-} 2>/dev/null || true
            wait ${QUAL_PID:-} 2>/dev/null || true
            set -e
          }

          trap terminate_children INT TERM

          (
            set +e
            "${FAC_BIN[@]}" fac review run "${PR_URL}" --type security --expected-head-sha "${HEAD_SHA}" >"${SEC_LOG}" 2>&1
            echo "$?" >"${RUN_DIR}/security.exit"
          ) &
          SEC_PID=$!

          (
            set +e
            "${FAC_BIN[@]}" fac review run "${PR_URL}" --type quality --expected-head-sha "${HEAD_SHA}" >"${QUAL_LOG}" 2>&1
            echo "$?" >"${RUN_DIR}/quality.exit"
          ) &
          QUAL_PID=$!

          LAST_SEQ=0

          while kill -0 "${SEC_PID}" 2>/dev/null || kill -0 "${QUAL_PID}" 2>/dev/null; do
            NOW=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            STATUS_JSON=$("${FAC_BIN[@]}" fac --json review status --pr "${PR_NUMBER}" 2>/dev/null || true)

            if [[ -z "${STATUS_JSON}" ]] || ! jq -e . >/dev/null 2>&1 <<<"${STATUS_JSON}"; then
              echo "ts=${NOW} security=unknown quality=unknown events=-"
              sleep 1
              continue
            fi

            SEC_STATE=$(jq -r '
              ([.state_entries[]? | select(.review_type == "security")] | first) as $s
              | if $s == null then
                  "none"
                else
                  (if ($s.alive // false) then "alive" else "done" end)
                  + ":" + ($s.model // "n/a") + "/" + ($s.backend // "n/a")
                  + ":r" + (($s.restart_count // 0) | tostring)
                  + ":" + (($s.head_sha // "-") | tostring | .[0:7])
                end
            ' <<<"${STATUS_JSON}")

            QUAL_STATE=$(jq -r '
              ([.state_entries[]? | select(.review_type == "quality")] | first) as $s
              | if $s == null then
                  "none"
                else
                  (if ($s.alive // false) then "alive" else "done" end)
                  + ":" + ($s.model // "n/a") + "/" + ($s.backend // "n/a")
                  + ":r" + (($s.restart_count // 0) | tostring)
                  + ":" + (($s.head_sha // "-") | tostring | .[0:7])
                end
            ' <<<"${STATUS_JSON}")

            LAST_EVENTS=$(jq -r '
              [.recent_events[]? | .event // empty] | .[-2:] | join(",") | if . == "" then "-" else . end
            ' <<<"${STATUS_JSON}")

            echo "ts=${NOW} security=${SEC_STATE} quality=${QUAL_STATE} events=${LAST_EVENTS}"

            NEW_ERRORS=$(jq -c --argjson last "${LAST_SEQ}" '
              [.recent_events[]?
                | select((.seq // 0) > $last)
                | select(
                    .event == "run_crash"
                    or .event == "stall_detected"
                    or .event == "model_fallback"
                    or .event == "sha_update"
                  )
              ]
            ' <<<"${STATUS_JSON}")

            if [[ "$(jq 'length' <<<"${NEW_ERRORS}")" -gt 0 ]]; then
              jq -r '
                .[]
                | "ERROR ts=\(.ts // \"-\") event=\(.event // \"-\") review=\(.review_type // \"-\") seq=\(.seq // 0) detail=\((.reason // .signal // .exit_code // .new_sha // \"-\") | tostring)"
              ' <<<"${NEW_ERRORS}"
            fi

            MAX_SEQ=$(jq -r '[.recent_events[]? | (.seq // 0)] | max // 0' <<<"${STATUS_JSON}")
            if (( MAX_SEQ > LAST_SEQ )); then
              LAST_SEQ=${MAX_SEQ}
            fi

            sleep 1
          done

          set +e
          wait "${SEC_PID}"; SEC_EXIT=$?
          wait "${QUAL_PID}"; QUAL_EXIT=$?
          set -e

          trap - INT TERM

          NOW=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "ts=${NOW} security_exit=${SEC_EXIT} quality_exit=${QUAL_EXIT} run_dir=${RUN_DIR}"

          if [[ ${SEC_EXIT} -ne 0 ]]; then
            echo "ERROR security review failed with exit=${SEC_EXIT}"
            tail -n 40 "${SEC_LOG}" || true
          fi

          if [[ ${QUAL_EXIT} -ne 0 ]]; then
            echo "ERROR quality review failed with exit=${QUAL_EXIT}"
            tail -n 40 "${QUAL_LOG}" || true
          fi

          if [[ ${SEC_EXIT} -ne 0 || ${QUAL_EXIT} -ne 0 ]]; then
            exit 1
          fi

      # Review Gate Success status is posted exclusively by
      # .github/workflows/review-gate.yml (trusted base-branch evaluator).
      # This workflow only posts review comments; review-gate re-evaluates on
      # issue_comment and projects the required status.
