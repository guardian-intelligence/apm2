# Authoritative AI review gate workflow
# Runs gate evaluation with trusted base-branch code.

name: Review Gate

on:
  pull_request_target:
    branches: [main]
  issue_comment:
    types: [created, edited]

concurrency:
  group: review-gate-${{ github.event_name == 'pull_request_target' && github.event.pull_request.number || github.event.issue.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: read
  statuses: write

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  RUSTFLAGS: -D warnings
  RUST_BACKTRACE: 1

jobs:
  # Pre-filter for issue_comment events: only run for comments from trusted
  # actors on pull requests, preventing unbounded CI-trigger DoS from arbitrary
  # commenters.
  pre-filter:
    name: Pre-filter
    if: >-
      github.event_name == 'pull_request_target' ||
      (
        github.event_name == 'issue_comment' &&
        github.event.issue.pull_request &&
        (
          github.event.comment.author_association == 'OWNER' ||
          github.event.comment.author_association == 'MEMBER' ||
          github.event.comment.author_association == 'COLLABORATOR'
        )
      )
    runs-on: &primary_runner [self-hosted, linux, x64, fac-ovh]
    steps:
      - run: echo "Pre-filter passed"

  review-gate:
    name: Review Gate
    needs: [pre-filter]
    runs-on: *primary_runner
    outputs:
      gate_state: ${{ steps.evaluate.outputs.gate_state }}
    steps:
      # pull_request_target already executes in base-branch context, so this
      # checks out trusted evaluator code from the PR base branch.
      - name: Checkout trusted base branch code
        if: github.event_name == 'pull_request_target'
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      # For issue_comment, resolve the PR base ref first, then checkout that
      # branch so evaluator code matches the PR's target branch policy.
      - name: Resolve PR base ref for issue_comment
        if: github.event_name == 'issue_comment'
        id: ic-base
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ github.event.issue.number }}"
          BASE_REF=$(gh api "/repos/${{ github.repository }}/pulls/${PR_NUMBER}" --jq '.base.ref')
          echo "base_ref=${BASE_REF}" >> "$GITHUB_OUTPUT"

      - name: Checkout trusted base branch code (issue_comment)
        if: github.event_name == 'issue_comment'
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          ref: ${{ steps.ic-base.outputs.base_ref }}

      - uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561 # stable
        with:
          toolchain: stable
      - name: Install protoc
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler
      - uses: Swatinem/rust-cache@ad397744b0d591a723ab90405b7247fac0e6b8db # v2

      # Resolve PR number and head SHA.
      # For pull_request_target these come from the event payload directly.
      # For issue_comment we resolve via the GitHub API.
      - name: Resolve PR context
        id: pr-ctx
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" = "pull_request_target" ]; then
            echo "pr_number=${{ github.event.pull_request.number }}" >> "$GITHUB_OUTPUT"
            echo "head_sha=${{ github.event.pull_request.head.sha }}" >> "$GITHUB_OUTPUT"
            echo "base_ref=${{ github.event.pull_request.base.ref }}" >> "$GITHUB_OUTPUT"
          else
            PR_NUMBER="${{ github.event.issue.number }}"
            PR_DATA=$(gh api "/repos/${{ github.repository }}/pulls/${PR_NUMBER}")
            HEAD_SHA=$(echo "$PR_DATA" | jq -r '.head.sha')
            BASE_REF=$(echo "$PR_DATA" | jq -r '.base.ref')
            echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
            echo "head_sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"
            echo "base_ref=${BASE_REF}" >> "$GITHUB_OUTPUT"
          fi

      - name: Fetch trusted-reviewers from base branch
        run: |
          git fetch origin "${{ steps.pr-ctx.outputs.base_ref }}" --depth=1
          git show "origin/${{ steps.pr-ctx.outputs.base_ref }}:.github/review-gate/trusted-reviewers.json" \
            > /tmp/trusted-reviewers-base.json

      - name: Project ai-review statuses from trusted review comments
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ steps.pr-ctx.outputs.pr_number }}
          HEAD_SHA: ${{ steps.pr-ctx.outputs.head_sha }}
        run: |
          python3 - <<'PY'
          import json
          import os
          import re
          import subprocess
          from datetime import datetime, timezone

          repo = os.environ["GITHUB_REPOSITORY"]
          pr_number = os.environ["PR_NUMBER"]
          head_sha = os.environ["HEAD_SHA"]
          trusted_reviewers_path = "/tmp/trusted-reviewers-base.json"

          def parse_iso8601(ts: str) -> datetime:
              return datetime.fromisoformat(ts.replace("Z", "+00:00")).astimezone(timezone.utc)

          def gh_api(endpoint: str):
              output = subprocess.check_output(["gh", "api", endpoint], text=True)
              return json.loads(output)

          def post_status(context: str, state: str, description: str) -> None:
              subprocess.check_call(
                  [
                      "gh",
                      "api",
                      "--method",
                      "POST",
                      f"/repos/{repo}/statuses/{head_sha}",
                      "-f",
                      f"state={state}",
                      "-f",
                      f"context={context}",
                      "-f",
                      f"description={description[:140]}",
                  ]
              )

          def trusted_logins(payload: dict, category: str) -> set[str]:
              entries = payload["reviewers"][category]
              logins: set[str] = set()
              for entry in entries:
                  for login in entry.get("github_logins", []):
                      logins.add(login.lower())
              return logins

          with open(trusted_reviewers_path, "r", encoding="utf-8") as handle:
              trusted_payload = json.load(handle)

          allowlisted = {
              "security": trusted_logins(trusted_payload, "security"),
              "code-quality": trusted_logins(trusted_payload, "code_quality"),
          }

          head_commit = gh_api(f"/repos/{repo}/commits/{head_sha}")
          head_commit_ts = parse_iso8601(head_commit["commit"]["committer"]["date"])

          comments = []
          for page in range(1, 51):
              batch = gh_api(
                  f"/repos/{repo}/issues/{pr_number}/comments?per_page=100&page={page}"
              )
              if not batch:
                  break
              comments.extend(batch)

          patterns = {
              "security": re.compile(r"(?im)^##\s*Security Review\s*:\s*(PASS|FAIL)\b"),
              "code-quality": re.compile(r"(?im)^##\s*Code Quality Review\s*:\s*(PASS|FAIL)\b"),
          }

          contexts = {
              "security": "ai-review/security",
              "code-quality": "ai-review/code-quality",
          }

          for category in ("security", "code-quality"):
              best = None
              for comment in comments:
                  body = comment.get("body") or ""
                  login = (comment.get("user") or {}).get("login", "").lower()
                  if login not in allowlisted[category]:
                      continue
                  if head_sha.lower() not in body.lower():
                      continue

                  timestamp_raw = comment.get("updated_at") or comment.get("created_at")
                  if not timestamp_raw:
                      continue
                  timestamp = parse_iso8601(timestamp_raw)
                  if timestamp < head_commit_ts:
                      continue

                  verdict_match = patterns[category].search(body)
                  if not verdict_match:
                      continue

                  verdict = verdict_match.group(1).upper()
                  if verdict not in ("PASS", "FAIL"):
                      continue

                  rank = (timestamp, int(comment.get("id", 0)))
                  if best is None or rank > best["rank"]:
                      best = {
                          "rank": rank,
                          "comment_id": int(comment.get("id", 0)),
                          "state": "success" if verdict == "PASS" else "failure",
                          "description": f"{category} review {verdict} (comment #{int(comment.get('id', 0))})",
                      }

              if best is None:
                  state = "pending"
                  description = (
                      f"Waiting for trusted {category} verdict on {head_sha[:12]}"
                  )
              else:
                  state = best["state"]
                  description = best["description"]

              context = contexts[category]
              print(
                  json.dumps(
                      {
                          "context": context,
                          "state": state,
                          "description": description,
                          "category": category,
                      }
                  )
              )
              post_status(context, state, description)
          PY

      - name: Evaluate review gate
        id: evaluate
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set +e
          cargo xtask review-gate \
            --repo "${{ github.repository }}" \
            --pr-number "${{ steps.pr-ctx.outputs.pr_number }}" \
            --head-sha "${{ steps.pr-ctx.outputs.head_sha }}" \
            --trusted-reviewers "/tmp/trusted-reviewers-base.json" \
            | tee /tmp/review-gate-evaluation.json
          code=$?
          set -e
          if [ "$code" -eq 0 ]; then
            echo "gate_state=success" >> "$GITHUB_OUTPUT"
          elif [ "$code" -eq 2 ]; then
            echo "gate_state=pending" >> "$GITHUB_OUTPUT"
          else
            if jq -e '.security.authoritative_verdict == "FAIL" or .code_quality.authoritative_verdict == "FAIL"' \
              /tmp/review-gate-evaluation.json >/dev/null 2>&1; then
              echo "gate_state=failure" >> "$GITHUB_OUTPUT"
            else
              # Fail-open noise reduction: if no authoritative FAIL exists for
              # current head SHA, keep the gate pending until reviewers post a
              # decisive verdict.
              echo "gate_state=pending" >> "$GITHUB_OUTPUT"
            fi
          fi

  review-gate-success:
    name: Review Gate Success
    needs: [pre-filter, review-gate]
    if: always()
    runs-on: *primary_runner
    steps:
      - name: Check review gate result
        id: gate
        run: |
          # If pre-filter was skipped (untrusted commenter), gate is not
          # applicable. Do NOT post any status — an untrusted actor must
          # never be able to write a passing required status.
          if [[ "${{ needs.pre-filter.result }}" == "skipped" ]]; then
            echo "Pre-filter skipped (not a trusted actor or not a PR comment)"
            echo "should_post=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "should_post=true" >> "$GITHUB_OUTPUT"

          # Read gate_state from the review-gate job output.
          # If the output is empty/unknown, default to pending so new PRs do
          # not fail hard before any trusted reviewer decision exists.
          GATE_STATE="${{ needs.review-gate.outputs.gate_state }}"
          if [[ -z "$GATE_STATE" ]]; then
            GATE_STATE="pending"
          fi

          case "$GATE_STATE" in
            success)
              echo "Review gate passed"
              echo "state=success" >> "$GITHUB_OUTPUT"
              echo "description=Review gate passed" >> "$GITHUB_OUTPUT"
              ;;
            failure)
              echo "Review gate failed (authoritative FAIL verdict)"
              echo "state=failure" >> "$GITHUB_OUTPUT"
              echo "description=Review gate failed" >> "$GITHUB_OUTPUT"
              ;;
            pending)
              echo "Review gate pending — waiting for AI reviews"
              echo "state=pending" >> "$GITHUB_OUTPUT"
              echo "description=Waiting for AI reviews" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "Review gate state unknown ($GATE_STATE); treating as pending"
              echo "state=pending" >> "$GITHUB_OUTPUT"
              echo "description=Waiting for AI reviews" >> "$GITHUB_OUTPUT"
              ;;
          esac

      # Resolve the PR head SHA so we can post a commit status to it.
      # Only resolve when the gate actually ran (avoids API calls on
      # non-PR issue_comment events where pre-filter was skipped).
      - name: Resolve PR head SHA
        id: head
        if: always() && steps.gate.outputs.should_post == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" = "pull_request_target" ]; then
            echo "sha=${{ github.event.pull_request.head.sha }}" >> "$GITHUB_OUTPUT"
          else
            PR_NUMBER="${{ github.event.issue.number }}"
            HEAD_SHA=$(gh api "/repos/${{ github.repository }}/pulls/${PR_NUMBER}" --jq '.head.sha')
            echo "sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"
          fi

      # Post a commit status to the PR head SHA so branch protection can
      # find the check on the correct commit (pull_request_target runs
      # report on the base SHA, not the PR head).
      # Only post when the gate actually ran (trusted actor triggered it).
      - name: Post review gate status to PR head
        if: >-
          always() &&
          steps.gate.outputs.should_post == 'true' &&
          steps.head.outputs.sha != ''
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh api --method POST "/repos/${{ github.repository }}/statuses/${{ steps.head.outputs.sha }}" \
            -f state="${{ steps.gate.outputs.state || 'failure' }}" \
            -f context="Review Gate Success" \
            -f description="${{ steps.gate.outputs.description || 'Review gate evaluation failed' }}"
