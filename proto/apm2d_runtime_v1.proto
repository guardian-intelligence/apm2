syntax = "proto3";

package apm2.daemon.v1;

// CTR-PROTO-001: Handshake
message Hello {
  uint32 protocol_version = 1;
  ClientInfo client_info = 2;
  repeated string requested_caps = 3;
}

message HelloAck {
  ServerInfo server_info = 1;
  repeated string granted_caps = 2;
  bytes policy_hash = 3;
  map<string, uint32> canonicalizer_versions = 4;
}

message ClientInfo {
  string name = 1;
  string version = 2;
}

message ServerInfo {
  string name = 1;
  string version = 2;
}

// CTR-PROTO-002: Episode Control
message CreateEpisode {
  bytes envelope_hash = 1;
}

message EpisodeCreated {
  string episode_id = 1;
  string session_id = 2;
}

message StartEpisode {
  string episode_id = 1;
}

message EpisodeStarted {
  uint32 session_pid = 1;
  string io_stream_id = 2;
}

message StopEpisode {
  string episode_id = 1;
  StopReason reason = 2;
}

message EpisodeStopped {
  TerminationClass termination_class = 1;
}

message SignalEpisode {
  string episode_id = 1;
  int32 signal = 2;
}

message ResizePty {
  string episode_id = 1;
  uint32 cols = 2;
  uint32 rows = 3;
}

// Minimal v1 vocabulary for evidence economics
message EpisodeQuarantined {
  string episode_id = 1;
  string reason = 2;
  repeated bytes evidence_pinned = 3;
}

enum StopReason {
  STOP_REASON_UNSPECIFIED = 0;
  GOAL_SATISFIED = 1;
  BUDGET_EXHAUSTED = 2;
  POLICY_VIOLATION = 3;
  USER_REQUEST = 4;
  HARNESS_CRASH = 5;
  ADAPTER_FAILURE = 6;
}

enum TerminationClass {
  TERMINATION_CLASS_UNSPECIFIED = 0;
  CLEAN_EXIT = 1;
  ERROR_EXIT = 2;
  QUARANTINED = 3;
}

// CTR-PROTO-003: I/O
message SendInput {
  string episode_id = 1;
  bytes data = 2;
}

message StreamOutput {
  bytes chunk = 1;
  StreamKind kind = 2;
  uint64 seq = 3;
  uint64 ts = 4;
}

enum StreamKind {
  STDOUT = 0;
  STDERR = 1;
}

// CTR-PROTO-004: Tool Mediation
message ToolRequest {
  string episode_id = 1;
  string request_id = 2;
  string tool = 3;
  bytes dedupe_key = 4;
  bytes args_hash = 5;
  optional bytes inline_args = 6;
}

message ToolDecision {
  string request_id = 1;
  DecisionType decision = 2;
  optional string rule_id = 3;
  bytes policy_hash = 4;
  BudgetDelta budget_delta = 5;
}

enum DecisionType {
  ALLOW = 0;
  DENY = 1;
  DEDUPE_HIT = 2;
}

message ToolResult {
  string request_id = 1;
  ToolOutcome outcome = 2;
  bytes result_hash = 3;
  optional bytes inline_result = 4;
}

message BudgetDelta {
  uint64 tokens = 1;
  uint32 tool_calls = 2;
  uint64 cpu_ms = 3;
}

enum ToolOutcome {
  TOOL_OUTCOME_UNSPECIFIED = 0;
  SUCCESS = 1;
  FAILURE = 2;
  ERROR = 3;
}

// CTR-PROTO-005: Telemetry
message TelemetryFrame {
  string episode_id = 1;
  uint64 seq = 2;
  uint64 ts_mono = 3;
  uint64 cpu_ns = 4;
  uint64 mem_rss_bytes = 5;
  uint64 io_read_bytes = 6;
  uint64 io_write_bytes = 7;
  optional CgroupStats cgroup_stats = 8;
  uint32 o11y_flags = 9;
}

message CgroupStats {
  uint64 cpu_usage_usec = 1;
  uint64 memory_current = 2;
  uint64 memory_max = 3;
}

message TelemetryPolicy {
  uint64 sample_period_ms = 1;
  repeated PromoteTrigger promote_triggers = 2;
  RingBufferLimits ring_buffer_limits = 3;
}

message PromoteTrigger {
  string metric = 1;
  double threshold = 2;
}

message RingBufferLimits {
  uint64 max_pty_bytes = 1;
  uint64 max_tool_bytes = 2;
  uint64 max_tel_frames = 3;
}

// CTR-PROTO-006: Receipts and Evidence
message PublishEvidence {
  bytes artifact_hash = 1;
  EvidenceKind kind = 2;
  RetentionHint retention_hint = 3;
}

message Receipt {
  ReceiptKind kind = 1;
  bytes unsigned_bytes_hash = 2;
  bytes signature = 3;
  repeated bytes evidence_refs = 4;
  bytes policy_hash = 5;
  bytes envelope_hash = 6;
  optional string issuer_id = 7;
  optional bytes issuer_signature = 8;
}

// Minimal v1 vocabulary events for evidence economics
message EvidencePinned {
  bytes artifact_hash = 1;
  string reason = 2;
  optional string defect_id = 3;
}

message EvidenceTtlExpired {
  bytes artifact_hash = 1;
  uint64 timestamp = 2;
}

message CompactionCompleted {
  bytes summary_receipt_hash = 1;
  repeated bytes tombstoned_hashes = 2;
}

enum ReceiptKind {
  TOOL_EXECUTION = 0;
  EPISODE_START = 1;
  EPISODE_STOP = 2;
  GATE = 3;
  TELEMETRY = 4;
  COMPACTION = 5;
  STOP_ORDER = 6;
}

enum EvidenceKind {
  EVIDENCE_KIND_UNSPECIFIED = 0;
  EVIDENCE_KIND_PTY_TRANSCRIPT = 1;
  EVIDENCE_KIND_TOOL_IO = 2;
  EVIDENCE_KIND_TELEMETRY_RAW = 3;
  EVIDENCE_KIND_ADAPTER_FAILURE = 4;
  EVIDENCE_KIND_INCIDENT_SNAPSHOT = 5;
}

enum RetentionHint {
  RETENTION_HINT_UNSPECIFIED = 0;
  EPHEMERAL = 1;
  STANDARD = 2;
  ARCHIVAL = 3;
}

// =============================================================================
// CTR-PROTO-007: Privileged Endpoints (RFC-0017)
// =============================================================================
// These endpoints require operator credentials (connection on operator.sock).
// Session connections receive PERMISSION_DENIED for all privileged requests.

// Role enumeration for work claiming and episode spawning.
enum WorkRole {
  WORK_ROLE_UNSPECIFIED = 0;
  IMPLEMENTER = 1;
  GATE_EXECUTOR = 2;
  REVIEWER = 3;
  COORDINATOR = 4;
}

// IPC-PRIV-001: ClaimWork
// Request work assignment with policy-resolved capabilities.
// Per DD-001: actor_id is a display hint; authoritative actor_id derived from credential.
message ClaimWorkRequest {
  // Display-only hint for actor name. Authoritative actor_id derived from credential.
  string actor_id = 1;
  // Role for work assignment.
  WorkRole role = 2;
  // Ed25519 signature over (actor_id || role || nonce) using operator key.
  bytes credential_signature = 3;
  // Nonce to prevent replay attacks.
  bytes nonce = 4;
}

message ClaimWorkResponse {
  // Assigned work identifier.
  string work_id = 1;
  // Lease identifier for this work claim.
  string lease_id = 2;
  // Blake3 hash of the capability manifest.
  bytes capability_manifest_hash = 3;
  // Reference to the PolicyResolvedForChangeSet event.
  string policy_resolved_ref = 4;
  // Blake3 hash of the sealed context pack.
  bytes context_pack_hash = 5;
}

// IPC-PRIV-002: SpawnEpisode
// Spawn execution episode with FAC preconditions.
message SpawnEpisodeRequest {
  // Work identifier from a prior ClaimWork.
  string work_id = 1;
  // Role for this episode (IMPLEMENTER, GATE_EXECUTOR, REVIEWER).
  WorkRole role = 2;
  // Required for GATE_EXECUTOR role; must reference valid GateLeaseIssued.
  optional string lease_id = 3;
}

message SpawnEpisodeResponse {
  // Session identifier for IPC communication.
  string session_id = 1;
  // Blake3 hash of the capability manifest governing this session.
  bytes capability_manifest_hash = 2;
  // Whether the context pack is sealed.
  bool context_pack_sealed = 3;
  // Ephemeral handle for session identification (not a credential).
  string ephemeral_handle = 4;
}

// IPC-PRIV-003: IssueCapability
// Issue additional capability to an existing session.
message IssueCapabilityRequest {
  // Target session identifier.
  string session_id = 1;
  // Capability request details.
  CapabilityRequest capability_request = 2;
}

message CapabilityRequest {
  // Tool class to grant access to.
  string tool_class = 1;
  // Path patterns for read access (optional).
  repeated string read_patterns = 2;
  // Path patterns for write access (optional).
  repeated string write_patterns = 3;
  // Duration in seconds for the capability grant.
  uint64 duration_secs = 4;
}

message IssueCapabilityResponse {
  // Unique identifier for this capability grant.
  string capability_id = 1;
  // Unix timestamp when capability was granted.
  uint64 granted_at = 2;
  // Unix timestamp when capability expires.
  uint64 expires_at = 3;
}

// IPC-PRIV-004: Shutdown
// Gracefully shutdown the daemon.
message ShutdownRequest {
  // Optional reason for shutdown (for logging/audit).
  optional string reason = 1;
}

message ShutdownResponse {
  // Acknowledgment message.
  string message = 1;
}

// =============================================================================
// Error Codes for Privileged Endpoints
// =============================================================================
enum PrivilegedErrorCode {
  PRIVILEGED_ERROR_UNSPECIFIED = 0;
  // Caller lacks operator credential (not on operator.sock).
  PERMISSION_DENIED = 1;
  // Invalid parameter in request.
  CAPABILITY_REQUEST_REJECTED = 2;
  // Governance policy resolution failed.
  POLICY_RESOLUTION_FAILED = 3;
  // Required policy resolution missing for spawn.
  POLICY_RESOLUTION_MISSING = 4;
  // GATE_EXECUTOR spawn requires valid lease.
  GATE_LEASE_MISSING = 5;
  // Custody domain overlap detected (separation of duties violation).
  SOD_VIOLATION = 6;
  // Referenced session not found.
  SESSION_NOT_FOUND = 7;
  // Capability grant denied by policy.
  CAPABILITY_DENIED = 8;
}

// Generic error response for privileged endpoints.
message PrivilegedError {
  PrivilegedErrorCode code = 1;
  string message = 2;
}