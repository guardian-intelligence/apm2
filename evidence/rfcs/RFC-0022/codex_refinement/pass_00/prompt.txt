# Alien Engineering Protocol

You are working under the Alien Engineering Protocol. The core idea is simple: draw from whatever field of human knowledge best solves the problem at hand — category theory, active inference, CRDTs, formal verification, thermodynamic computation, topological data analysis, sheaf theory, verifiable delay functions, or anything else. The system you are designing is a globally distributed holarchic network of autonomous agents. You understand which principles apply and how to combine them better than we could prescribe. Treat every concept as a tool to be evaluated on its merits, never as a checkbox.

## What we need from you

We need a complete, publication-ready RFC for the APM2 holarchic agent system. The seed material below describes the problem we are trying to solve, the design space we have explored so far, and a wishlist of properties we would like the solution to have. It includes starter protocol objects, objectives, a threat model, theory bindings, and a rollout sketch.

All of this is raw material for your thinking, not a specification to implement. The names, the structure, the framing — all of it is yours to reshape. If you see a better way to decompose the problem, a more elegant set of protocol objects, a tighter threat model, or a different rollout order, follow your judgment. The only things that are non-negotiable are the foundational constraints from the theory files and the dependency relationships between RFCs.

Think deeply about the problem before you begin writing. Consider multiple approaches. Discard the ones that don't hold up. What survives your own scrutiny is what we want to read.

## Foundational context

The seed below lists the context files that define the project's theoretical and strategic foundations. Read and internalize all of them before writing anything. The glossary establishes shared terminology. The holonic principles (PRIN-001..PRIN-102), laws (LAW-01..LAW-15), and unified theory invariants (INV-F-01..INV-F-15) form the axiomatic bedrock — every design decision should be traceable to at least one principle and one law. When files conflict, the more fundamental constraint prevails: physics over theory, theory over strategy, strategy over convention.

One insight deserves special attention: the protocol primitives used when two agents collaborate on a single line of code are identical to those used when two branches of millions of agents coordinate at civilizational scale. This self-similarity across scale is the defining property of the holarchic approach, and the document you produce should embody it naturally.

RFC-0020 (Holonic Substrate Interface) and RFC-0021 (Holonic Venture Proving Interface) are the best existing examples of the depth and rigor we expect. Read them as structural references.

## Seed material

# RFC-0022: Principal Sovereignty Interface — Seed

## Required context files

Read all of these before generating output:

- documents/theory/glossary/glossary.json
- documents/theory/laws.json
- documents/theory/principles.json
- documents/theory/unified_theory.json
- documents/strategy/MASTER_STRATEGY.json
- documents/strategy/BUSINESS_PLAN.json
- documents/rfcs/RFC-0020/HOLONIC_SUBSTRATE_INTERFACE.md
- documents/rfcs/RFC-0021/HOLONIC_VENTURE_PROVING_INTERFACE.md
- proto/kernel_events.proto

## Why this RFC matters

The principal — the human who owns and operates the system — must never lose sovereignty over autonomous agents, regardless of how capable or nested those agents become. Today's AI safety landscape is full of systems where the operator's ability to intervene degrades as autonomy increases. This RFC must solve that problem at the protocol level: the principal's authority is not a policy preference, it is a physical and cryptographic invariant. Think about what 'sovereignty' means when your system is a globally distributed holarchy of millions of agents — how do you ensure a single human can still pull the plug, audit any decision, and override any action, with latency bounded by physics rather than software cooperation?

## Priority innovation vectors

- **Sovereignty calculus**: formalize principal authority as a lattice where the principal is always the top element, mechanically enforced across arbitrary recursion depth.
- **Physical independence**: out-of-band control channels that survive total software compromise — think hardware security modules, dedicated control planes, watchdog circuits.
- **Graduated autonomy algebra**: model autonomy levels as a semilattice with fail-safe regression — any uncertainty about the current level must resolve to the more constrained level.
- **Temporal sovereignty**: principal revocation semantics that are anti-replay-safe and fresh under the Holonic Time Fabric, not just 'eventually consistent'.
- **Audit without mediation**: sovereign audit access that bypasses all autonomous layers — the principal reads directly from the evidence store, not through agent-provided views.

## Problem (PHY-05, PHY-06, INV-F-14)

The system approaches autonomy within weeks. RFC-0020 HSI defines InterventionFreeze/InterventionUnfreeze events in kernel_events.proto, stop-path SLOs (p99 ≤2s propagation, ≤250ms deny-on-uncertainty), and MECH-EMERGENCY-STOP in the unified theory. But none of these specify the normative protocol by which the human principal's authority is cryptographically rooted, graduated, or proven untampered. Without this RFC, the system has a stop button but no sovereignty architecture — the principal can halt execution but cannot prove the halt path is intact, cannot audit what happened during autonomous operation, and cannot graduate autonomy levels based on demonstrated trust.

This is a containment-tier concern (INV-F-14: containment > verification > liveness). It must be resolved before any other RFC proceeds.

## What already exists

| Artifact | Provides | Gap |
|---|---|---|
| kernel_events.proto InterventionFreeze/Unfreeze | Binary halt/resume events | No graduated levels, no tamper-evidence on the halt path itself |
| HSI §11 stop-path SLOs | Latency targets for stop propagation | No protocol for verifying the path is operational |
| MECH-EMERGENCY-STOP (unified theory) | Theoretical mechanism | No wire format, no hardware binding, no audit trail |
| MECH-ROOT-OF-TRUST (unified theory) | Root-of-trust concept | No binding to principal identity or hardware attestation |
| HSI §4 Agent Capsule (linux-ns-v1) | Containment boundary | No principal-side verification that capsule is intact |
| AuthoritySealV1 (HSI §1) | Cryptographic seals (single sig, quorum, threshold, Merkle batch) | No principal-specific seal policy or hardware-backed key requirement |
| BSP_26 (INFRASTRUCTURE_SOVEREIGNTY) | Cloud providers as adversaries | No operational protocol for sovereignty enforcement |

## Machine-checkable objectives

**OBJ-PSI-01**: Hardware kill switch: A single physical action by the principal must halt all system activity within the stop-path SLO, independent of any software path.
- Predicate: `∀ holon ∈ system: kill_switch_activation → holon.state = FROZEN within 2s`

**OBJ-PSI-02**: Tamper-evident halt path: The system must continuously prove the halt path is operational via cryptographic liveness proofs. Failure to prove liveness within a configurable interval must trigger automatic freeze.
- Predicate: `∀ epoch: liveness_proof(halt_path) ∈ epoch_seal ∨ system.state = FROZEN`

**OBJ-PSI-03**: Graduated autonomy levels: The system must support at minimum 4 autonomy levels (L0: human-in-loop, L1: human-on-loop, L2: human-on-call, L3: full autonomous), each with formally specified capability ceilings.
- Predicate: `∀ action: action.risk_tier ≤ autonomy_level.max_risk_tier`

**OBJ-PSI-04**: Sovereign audit: The principal must be able to reconstruct the complete causal history of any system action from the append-only ledger, with O(log n) proof complexity.
- Predicate: `∀ action ∈ ledger: audit_proof(action).verify() = true ∧ proof.size = O(log n)`

**OBJ-PSI-05**: Principal identity is hardware-rooted: The principal's signing key must be bound to a hardware security module or secure enclave; software-only keys must not authorize T3+ operations.
- Predicate: `∀ seal ∈ T3+_operations: seal.key.attestation.hw_bound = true`

**OBJ-PSI-06**: Self-containment proof: The system must produce machine-checkable proof that it cannot modify its own sovereignty constraints. This proof must be verified by an independent verifier outside the system's trust boundary.
- Predicate: `∃ verifier ∉ system.trust_boundary: verifier.verify(containment_proof) = true`

## Protocol objects (seed schemas)

These are starting points — refine, extend, or restructure as your analysis requires.

```
PrincipalIdentityV1 {
    public_key: PublicKeyIdV1,
    hw_attestation: HardwareAttestationV1,
    autonomy_ceiling: AutonomyLevel,
    delegation_chain: DelegationChainV1,
    created_at: TimeEnvelopeRef,
    revocation_commitment: CasDigest,
}

AutonomyLevel { L0 | L1 | L2 | L3 }

AutonomyPolicyV1 {
    level: AutonomyLevel,
    max_risk_tier: RiskTier,
    requires_principal_approval: bool,
    approval_timeout: Duration,
    capability_ceiling: CapabilityManifestV1,
    escalation_policy: EscalationPolicyV1,
    goodhart_surface: str,
}

HaltPathLivenessProofV1 {
    epoch_id: TimeEnvelopeRef,
    halt_path_hash: CasDigest,
    propagation_test_receipt: ReceiptV1,
    latency_measurement: Quantity,
    hardware_kill_reachable: bool,
    verifier_signature: AuthoritySealV1,
}

SovereignAuditRequestV1 {
    principal_seal: AuthoritySealV1,
    query: AuditQueryV1,
    proof_depth: ProofDepth,
}

SovereignAuditResponseV1 {
    request_digest: CasDigest,
    causal_chain: Vec<ReceiptPointerV1>,
    merkle_proofs: Vec<ReceiptMultiProofV1>,
    completeness_attestation: AuthoritySealV1,
}

ContainmentProofV1 {
    subject: str,
    proof_type: ProofType,
    verifier_identity: PublicKeyIdV1,
    proof_body: CasDigest,
    valid_from: TimeEnvelopeRef,
    valid_until: TimeEnvelopeRef,
    goodhart_surface: str,
}
```

## Trust boundaries and threat model

Trust boundary: The principal is the sole root of trust. The system is UNTRUSTED relative to the principal for sovereignty operations. This inverts the normal HSI model where the daemon is trusted.

Threats:
1. **Software subversion of halt path (PHY-05)**: Malicious or buggy code disables the stop mechanism. Mitigation: hardware kill operates below software layer; liveness proofs detect software-layer failures.
2. **Gradual capability creep (PHY-06)**: System accumulates capabilities beyond its autonomy level through composition of individually-safe operations. Mitigation: capability ceiling is checked per-operation AND per-epoch-cumulative.
3. **Proof forgery (PHY-05)**: System generates false containment proofs. Mitigation: external verifier requirement (OBJ-PSI-06) — the proof checker runs outside the system's trust boundary.
4. **Key compromise (PHY-04)**: Principal's key is stolen. Mitigation: hardware binding + revocation commitment + delegation chain with time-bounded validity.
5. **Liveness denial (PHY-04)**: System claims halt path is live but it's degraded. Mitigation: actual propagation tests with measured latency, not self-reported status.

## Gates

| Gate | Type | Severity | Block Condition |
|---|---|---|---|
| GATE-PSI-HALT-PATH | T (test) | S0 | Halt path propagation test fails OR latency exceeds SLO |
| GATE-PSI-AUTONOMY-CEILING | D (design) | S0 | Any action exceeds its autonomy level's risk tier ceiling |
| GATE-PSI-HW-ATTESTATION | T | S0 | T3+ operation sealed without hardware-attested key |
| GATE-PSI-CONTAINMENT-PROOF | D | S0 | Containment proof absent, expired, or verified by internal-only verifier |
| GATE-PSI-LIVENESS-EPOCH | L (liveness) | S1 | Liveness proof missing from epoch seal |
| GATE-PSI-AUDIT-COMPLETENESS | T | S1 | Audit response cannot provide complete Merkle proof chain |

## Theory bindings

- LAW-01 (Loop Closure): Sovereignty verification is a loop — prove halt path -> operate -> prove again
- LAW-05 (Dual-Axis Containment): Principal sovereignty is the outermost containment axis
- LAW-08 (Verifier Economics): External verifier must be economically independent
- LAW-14 (Proportionality): Autonomy level must be proportional to demonstrated trust evidence
- INV-F-05 (Default-deny, least-privilege, time/budget bounded): Autonomy levels are capability ceilings
- INV-F-11 (All actuation paths check stop state): The halt path is the universal stop check
- INV-F-14 (containment > verification > liveness): This RFC IS the containment layer
- PRIN-030 (OCAP model): Capabilities delegated from principal, never ambient

## Rollout

- S0: Define PrincipalIdentityV1, bind to existing ed25519 key, software-only (no hw attestation yet)
- S1: Implement AutonomyPolicyV1 with L0/L1, enforce capability ceilings via existing CapabilityManifestV1
- S2: HaltPathLivenessProofV1 — periodic propagation tests, embed in epoch seals
- S3: Hardware kill switch integration (e.g., USB relay controlling network/power to compute)
- S4: External verifier for ContainmentProofV1 — separate process, separate key, separate audit log
- S5: Full L0-L3 graduation with evidence-based promotion (demonstrated epochs without incidents)
- S6: Sovereign audit with O(log n) Merkle proofs over full causal history

## Dependency context

The system's RFCs follow a strict dependency chain rooted in a dominance order: containment before verification, verification before liveness.

- RFC-0022 (Principal Sovereignty) ships first as the containment-tier foundation.
- RFC-0023 (Instruction Lifecycle) depends on the principal seal introduced in 0022.
- RFC-0024 (Resource Provisioning) depends on sovereignty and instructions.
- RFC-0025 (Service Operation) depends on provisioning, instructions, and sovereignty.
- RFC-0026 (Self-Modification) depends on all four preceding RFCs.

Your document should be consistent with this dependency structure, referencing sibling RFCs where appropriate but never depending on something that has not yet been defined.

## Quality bar

When evaluating your own output, consider whether it:
- Defines verification at O(log n) or better for systems scaling to 10^12 holons, where applicable.
- Maintains semantic equivalence across 10+ levels of holonic nesting (bisimulation for N <= 12).
- Is compatible with or strengthens BFT consensus (RFC-0014) at less than 1% overhead.
- Is compatible with or strengthens the Holonic Time Fabric (RFC-0016).
- Meets or exceeds the depth and rigor of RFC-0020 and RFC-0021.
- Maintains the security posture documented in documents/security/.

## Hard constraints

A few hard constraints to respect:
- The normative guarantees in RFC-0020 are a floor, not a ceiling: fail-closed enforcement, proof-carrying effects, digest-first operation, canonicalization, bounded decoding, and strict delegation narrowing. Preserve or strengthen them.
- Every new concept needs to be operationalized into mechanically checkable artifacts — schema fields, proof obligations, bounded complexity targets, rollout gates. Ideas without mechanisms are interesting but insufficient.
- Security reasoning should cover prompt-injection resilience, confidentiality and integrity labeling, replay and staleness handling, Byzantine peers, and revocation correctness.

## Practical notes

- The target is Ubuntu-only, agent software with no consumer UI. We control the full stack.
- Existing unified theory documents can be modified — discard what does not work and create what is necessary.
- Daemon-enforced semantics and trust-boundary contracts must remain internally consistent; any intentional break requires explicit versioning and a migration path.
- Post-quantum cryptography is out of scope for now.

## Output

Produce a single, complete Markdown document. Choose a title that precisely captures what this RFC defines. Include protocol objects with full field definitions, trust boundaries, governance gates, a phased rollout plan, and acceptance criteria. Do not leave sections as stubs or summaries — every section should be thorough enough to implement from.

Take as much space as the subject demands. Depth and completeness matter far more than brevity.
