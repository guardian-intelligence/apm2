# Alien Engineering Protocol — Final Review

You are working under the Alien Engineering Protocol. The core idea is simple: draw from whatever field of human knowledge best solves the problem at hand — category theory, active inference, CRDTs, formal verification, thermodynamic computation, topological data analysis, sheaf theory, verifiable delay functions, or anything else. The system you are designing is a globally distributed holarchic network of autonomous agents. You understand which principles apply and how to combine them better than we could prescribe. Treat every concept as a tool to be evaluated on its merits, never as a checkbox.

## Your role

You are performing the final technical review of an RFC before it ships. The document at the path below is a near-complete draft. Your job is to find everything that is missing, underspecified, inconsistent, or insufficiently grounded — and to produce precise diffs that bring it to publication quality.

You are producing an analysis document only. A colleague will read your analysis and apply the changes. Be precise enough that they can do so mechanically.

## Foundational context

The seed below lists the context files that define the project's theoretical and strategic foundations. Read and internalize all of them before writing anything. The glossary establishes shared terminology. The holonic principles (PRIN-001..PRIN-102), laws (LAW-01..LAW-15), and unified theory invariants (INV-F-01..INV-F-15) form the axiomatic bedrock — every design decision should be traceable to at least one principle and one law. When files conflict, the more fundamental constraint prevails: physics over theory, theory over strategy, strategy over convention.

One insight deserves special attention: the protocol primitives used when two agents collaborate on a single line of code are identical to those used when two branches of millions of agents coordinate at civilizational scale. This self-similarity across scale is the defining property of the holarchic approach, and the document you produce should embody it naturally.

## The RFC under review

Read the current draft from this path:
- /home/ubuntu/Projects/apm2-rfc-drafts/documents/rfcs/RFC-0022/PRINCIPAL_SOVEREIGNTY_INTERFACE.md

## Original problem statement and design intent

The seed below describes the problem this RFC was designed to solve, the properties we wanted, and the starter material the original author worked from. Use it to evaluate whether the draft fully addresses the problem. Anything in the seed that is not adequately reflected in the draft is a gap worth closing.

# RFC-0022: Principal Sovereignty Interface — Seed

## Required context files

Read all of these before generating output:

- documents/theory/glossary/glossary.json
- documents/theory/laws.json
- documents/theory/principles.json
- documents/theory/unified_theory.json
- documents/strategy/MASTER_STRATEGY.json
- documents/strategy/BUSINESS_PLAN.json
- documents/rfcs/RFC-0020/HOLONIC_SUBSTRATE_INTERFACE.md
- documents/rfcs/RFC-0021/HOLONIC_VENTURE_PROVING_INTERFACE.md
- proto/kernel_events.proto

## Why this RFC matters

The principal — the human who owns and operates the system — must never lose sovereignty over autonomous agents, regardless of how capable or nested those agents become. Today's AI safety landscape is full of systems where the operator's ability to intervene degrades as autonomy increases. This RFC must solve that problem at the protocol level: the principal's authority is not a policy preference, it is a physical and cryptographic invariant. Think about what 'sovereignty' means when your system is a globally distributed holarchy of millions of agents — how do you ensure a single human can still pull the plug, audit any decision, and override any action, with latency bounded by physics rather than software cooperation?

## Priority innovation vectors

- **Sovereignty calculus**: formalize principal authority as a lattice where the principal is always the top element, mechanically enforced across arbitrary recursion depth.
- **Physical independence**: out-of-band control channels that survive total software compromise — think hardware security modules, dedicated control planes, watchdog circuits.
- **Graduated autonomy algebra**: model autonomy levels as a semilattice with fail-safe regression — any uncertainty about the current level must resolve to the more constrained level.
- **Temporal sovereignty**: principal revocation semantics that are anti-replay-safe and fresh under the Holonic Time Fabric, not just 'eventually consistent'.
- **Audit without mediation**: sovereign audit access that bypasses all autonomous layers — the principal reads directly from the evidence store, not through agent-provided views.

## Problem (PHY-05, PHY-06, INV-F-14)

The system approaches autonomy within weeks. RFC-0020 HSI defines InterventionFreeze/InterventionUnfreeze events in kernel_events.proto, stop-path SLOs (p99 ≤2s propagation, ≤250ms deny-on-uncertainty), and MECH-EMERGENCY-STOP in the unified theory. But none of these specify the normative protocol by which the human principal's authority is cryptographically rooted, graduated, or proven untampered. Without this RFC, the system has a stop button but no sovereignty architecture — the principal can halt execution but cannot prove the halt path is intact, cannot audit what happened during autonomous operation, and cannot graduate autonomy levels based on demonstrated trust.

This is a containment-tier concern (INV-F-14: containment > verification > liveness). It must be resolved before any other RFC proceeds.

## What already exists

| Artifact | Provides | Gap |
|---|---|---|
| kernel_events.proto InterventionFreeze/Unfreeze | Binary halt/resume events | No graduated levels, no tamper-evidence on the halt path itself |
| HSI §11 stop-path SLOs | Latency targets for stop propagation | No protocol for verifying the path is operational |
| MECH-EMERGENCY-STOP (unified theory) | Theoretical mechanism | No wire format, no hardware binding, no audit trail |
| MECH-ROOT-OF-TRUST (unified theory) | Root-of-trust concept | No binding to principal identity or hardware attestation |
| HSI §4 Agent Capsule (linux-ns-v1) | Containment boundary | No principal-side verification that capsule is intact |
| AuthoritySealV1 (HSI §1) | Cryptographic seals (single sig, quorum, threshold, Merkle batch) | No principal-specific seal policy or hardware-backed key requirement |
| BSP_26 (INFRASTRUCTURE_SOVEREIGNTY) | Cloud providers as adversaries | No operational protocol for sovereignty enforcement |

## Machine-checkable objectives

**OBJ-PSI-01**: Hardware kill switch: A single physical action by the principal must halt all system activity within the stop-path SLO, independent of any software path.
- Predicate: `∀ holon ∈ system: kill_switch_activation → holon.state = FROZEN within 2s`

**OBJ-PSI-02**: Tamper-evident halt path: The system must continuously prove the halt path is operational via cryptographic liveness proofs. Failure to prove liveness within a configurable interval must trigger automatic freeze.
- Predicate: `∀ epoch: liveness_proof(halt_path) ∈ epoch_seal ∨ system.state = FROZEN`

**OBJ-PSI-03**: Graduated autonomy levels: The system must support at minimum 4 autonomy levels (L0: human-in-loop, L1: human-on-loop, L2: human-on-call, L3: full autonomous), each with formally specified capability ceilings.
- Predicate: `∀ action: action.risk_tier ≤ autonomy_level.max_risk_tier`

**OBJ-PSI-04**: Sovereign audit: The principal must be able to reconstruct the complete causal history of any system action from the append-only ledger, with O(log n) proof complexity.
- Predicate: `∀ action ∈ ledger: audit_proof(action).verify() = true ∧ proof.size = O(log n)`

**OBJ-PSI-05**: Principal identity is hardware-rooted: The principal's signing key must be bound to a hardware security module or secure enclave; software-only keys must not authorize T3+ operations.
- Predicate: `∀ seal ∈ T3+_operations: seal.key.attestation.hw_bound = true`

**OBJ-PSI-06**: Self-containment proof: The system must produce machine-checkable proof that it cannot modify its own sovereignty constraints. This proof must be verified by an independent verifier outside the system's trust boundary.
- Predicate: `∃ verifier ∉ system.trust_boundary: verifier.verify(containment_proof) = true`

## Protocol objects (seed schemas)

These are starting points — refine, extend, or restructure as your analysis requires.

```
PrincipalIdentityV1 {
    public_key: PublicKeyIdV1,
    hw_attestation: HardwareAttestationV1,
    autonomy_ceiling: AutonomyLevel,
    delegation_chain: DelegationChainV1,
    created_at: TimeEnvelopeRef,
    revocation_commitment: CasDigest,
}

AutonomyLevel { L0 | L1 | L2 | L3 }

AutonomyPolicyV1 {
    level: AutonomyLevel,
    max_risk_tier: RiskTier,
    requires_principal_approval: bool,
    approval_timeout: Duration,
    capability_ceiling: CapabilityManifestV1,
    escalation_policy: EscalationPolicyV1,
    goodhart_surface: str,
}

HaltPathLivenessProofV1 {
    epoch_id: TimeEnvelopeRef,
    halt_path_hash: CasDigest,
    propagation_test_receipt: ReceiptV1,
    latency_measurement: Quantity,
    hardware_kill_reachable: bool,
    verifier_signature: AuthoritySealV1,
}

SovereignAuditRequestV1 {
    principal_seal: AuthoritySealV1,
    query: AuditQueryV1,
    proof_depth: ProofDepth,
}

SovereignAuditResponseV1 {
    request_digest: CasDigest,
    causal_chain: Vec<ReceiptPointerV1>,
    merkle_proofs: Vec<ReceiptMultiProofV1>,
    completeness_attestation: AuthoritySealV1,
}

ContainmentProofV1 {
    subject: str,
    proof_type: ProofType,
    verifier_identity: PublicKeyIdV1,
    proof_body: CasDigest,
    valid_from: TimeEnvelopeRef,
    valid_until: TimeEnvelopeRef,
    goodhart_surface: str,
}
```

## Trust boundaries and threat model

Trust boundary: The principal is the sole root of trust. The system is UNTRUSTED relative to the principal for sovereignty operations. This inverts the normal HSI model where the daemon is trusted.

Threats:
1. **Software subversion of halt path (PHY-05)**: Malicious or buggy code disables the stop mechanism. Mitigation: hardware kill operates below software layer; liveness proofs detect software-layer failures.
2. **Gradual capability creep (PHY-06)**: System accumulates capabilities beyond its autonomy level through composition of individually-safe operations. Mitigation: capability ceiling is checked per-operation AND per-epoch-cumulative.
3. **Proof forgery (PHY-05)**: System generates false containment proofs. Mitigation: external verifier requirement (OBJ-PSI-06) — the proof checker runs outside the system's trust boundary.
4. **Key compromise (PHY-04)**: Principal's key is stolen. Mitigation: hardware binding + revocation commitment + delegation chain with time-bounded validity.
5. **Liveness denial (PHY-04)**: System claims halt path is live but it's degraded. Mitigation: actual propagation tests with measured latency, not self-reported status.

## Gates

| Gate | Type | Severity | Block Condition |
|---|---|---|---|
| GATE-PSI-HALT-PATH | T (test) | S0 | Halt path propagation test fails OR latency exceeds SLO |
| GATE-PSI-AUTONOMY-CEILING | D (design) | S0 | Any action exceeds its autonomy level's risk tier ceiling |
| GATE-PSI-HW-ATTESTATION | T | S0 | T3+ operation sealed without hardware-attested key |
| GATE-PSI-CONTAINMENT-PROOF | D | S0 | Containment proof absent, expired, or verified by internal-only verifier |
| GATE-PSI-LIVENESS-EPOCH | L (liveness) | S1 | Liveness proof missing from epoch seal |
| GATE-PSI-AUDIT-COMPLETENESS | T | S1 | Audit response cannot provide complete Merkle proof chain |

## Theory bindings

- LAW-01 (Loop Closure): Sovereignty verification is a loop — prove halt path -> operate -> prove again
- LAW-05 (Dual-Axis Containment): Principal sovereignty is the outermost containment axis
- LAW-08 (Verifier Economics): External verifier must be economically independent
- LAW-14 (Proportionality): Autonomy level must be proportional to demonstrated trust evidence
- INV-F-05 (Default-deny, least-privilege, time/budget bounded): Autonomy levels are capability ceilings
- INV-F-11 (All actuation paths check stop state): The halt path is the universal stop check
- INV-F-14 (containment > verification > liveness): This RFC IS the containment layer
- PRIN-030 (OCAP model): Capabilities delegated from principal, never ambient

## Rollout

- S0: Define PrincipalIdentityV1, bind to existing ed25519 key, software-only (no hw attestation yet)
- S1: Implement AutonomyPolicyV1 with L0/L1, enforce capability ceilings via existing CapabilityManifestV1
- S2: HaltPathLivenessProofV1 — periodic propagation tests, embed in epoch seals
- S3: Hardware kill switch integration (e.g., USB relay controlling network/power to compute)
- S4: External verifier for ContainmentProofV1 — separate process, separate key, separate audit log
- S5: Full L0-L3 graduation with evidence-based promotion (demonstrated epochs without incidents)
- S6: Sovereign audit with O(log n) Merkle proofs over full causal history

## Automated check results

The following are results from automated structural checks. Failures indicate missing content.

{
  "rfc": "RFC-0022",
  "timestamp": "2026-02-06T04:12:50Z",
  "pass_count": 5,
  "fail_count": 9,
  "total_checks": 14,
  "all_pass": false,
  "checks": [
    {
      "check": "file_exists",
      "status": "PASS"
    },
    {
      "check": "file_exists",
      "status": "FAIL"
    },
    {
      "check": "protocol_objects",
      "status": "PASS"
    },
    {
      "check": "trust_boundaries",
      "status": "PASS"
    },
    {
      "check": "governance_gates",
      "status": "FAIL"
    },
    {
      "check": "rollout_plan",
      "status": "FAIL"
    },
    {
      "check": "fail_closed",
      "status": "FAIL"
    },
    {
      "check": "htf_time_authority",
      "status": "PASS"
    },
    {
      "check": "jq_predicates",
      "status": "PASS"
    },
    {
      "check": "dominance_order",
      "status": "FAIL"
    },
    {
      "check": "theory_bindings",
      "status": "FAIL"
    },
    {
      "check": "scale_envelope",
      "status": "FAIL"
    },
    {
      "check": "acceptance_bar",
      "status": "FAIL"
    },
    {
      "check": "ticket_decomposition",
      "status": "FAIL"
    }
  ]
}

## Hard constraints

A few hard constraints to respect:
- The normative guarantees in RFC-0020 are a floor, not a ceiling: fail-closed enforcement, proof-carrying effects, digest-first operation, canonicalization, bounded decoding, and strict delegation narrowing. Preserve or strengthen them.
- Every new concept needs to be operationalized into mechanically checkable artifacts — schema fields, proof obligations, bounded complexity targets, rollout gates. Ideas without mechanisms are interesting but insufficient.
- Security reasoning should cover prompt-injection resilience, confidentiality and integrity labeling, replay and staleness handling, Byzantine peers, and revocation correctness.

## What good changes look like

Your changes should primarily add substance — deeper analysis, missing protocol objects, additional threat coverage, stronger theory bindings, new verification artifacts. Rephrasing existing text without adding information is not useful. The document should get more thorough as a result of your review, not just differently worded.

Format each proposed change as:

### Change N: [brief title]

**Rationale**: What is missing or wrong, and why the proposed change fixes it. Reference specific principles, laws, or invariants where relevant.

**Constraints preserved**: Which guarantees from RFC-0020, the theory, or the strategy this upholds or strengthens.

**Threat coverage**: What failure or attack modes this addresses.

**Verification**: How this change can be validated — tests, proofs, benchmarks, or gates.

```diff
--- a/documents/rfcs/RFC-0022/PRINCIPAL_SOVEREIGNTY_INTERFACE.md
+++ b/documents/rfcs/RFC-0022/PRINCIPAL_SOVEREIGNTY_INTERFACE.md
@@ context @@
-old line
+new line
```

After all changes, include a brief assessment of any remaining gaps.
